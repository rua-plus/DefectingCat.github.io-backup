{"pageProps":{"postData":{"id":"vue3-notes","content":"\n> 早期学习 Vue3 API 的笔记。\n\n## setup\n\nsetup 方法在实例被创建（created）之前。\n\n### ref\n\n直接在 setup 中定义变量无法自动成为响应式，需要使用 ref 将其通过 proxy 代理为响应式变量。\n\n```js\nconst name = ref('xfy')\n```\n\n上述是`xfy`变为`Proxy({value: 'xfy'})`这样一个响应式引用。\n\n### reactive\n\nreactive 与 ref 类似，它直接将对象设置为响应式变量。\n\n```js\nconst state = reactive({\n    name: 'xfy'\n})\n```\n\n解构会使其失去响应性，需要使用 toRefs。\n\n### toRef\n\n使用 toRefs 解构时，如果解构的属性是可选的属性。那么 toRefs 不会自动创建默认值，这种情况下需要使用 toRef 来代替它。\n\n```js\n  props: {\n    msg: String,\n  },\n  setup(props) {\n    const name = toRef(props, \"name\");\n    console.log(name.value);\n    return {\n      name,\n    };\n  },\n```\n\ntoRef 如果对应的属性不存在，那么 toRef 会为其创建一个响应式的默认值。\n\n### 解构 reactive\n\nroRefs 可以解构响应式的变量，使其依然保持响应式。对于 reactive 创建的响应式变量也能使用 toRefs 来解构。\n\n```js\n  setup() {\n    const state = reactive({\n      name: \"xfy\",\n    });\n    const { name } = toRefs(state);\n    return {\n      name,\n    };\n  },\n```\n\n## Non-Props\n\n在 Vue3 中，在子组件中可以定义不 Props 属性。在父组件中传递 Props 给子组件时，有多种情况：\n\n* 单根，`inheritAttrs: false`\n\n  在默认情况下，子组件中不定义 Props 属性时，在父组件中传递的 Attribute 会直接传递给单根的子组件元素上。当定义了`inheritAttrs: false`时，将不默认转递 Attribute。\n\n* 多根，`inheritAttrs: false`\n\n  在子组件中有多个根元素的情况下，可以指定某个根元素继承 Attribute。使用`v-bind`方法。也可以直接访问传递的 Props：\n\n  ```html\n  <template>\n    <div>test</div>\n    <div v-bind=\"$attrs\">{{ $attrs.msg }}</div>\n    <div>test</div>\n  </template>\n  ```\n\n## Context\n\nSetup 方法接受两个参数，分别是传递的 Props 和 Context。Context 里分别有三个有用的属性：\n\n```js\n  setup(props, context) {\n    // Attribute (非响应式对象)\n    console.log(context.attrs)\n\n    // 插槽 (非响应式对象)\n    console.log(context.slots)\n\n    // 触发事件 (方法)\n    console.log(context.emit)\n  }\n```\n\n### attrs\n\nattrs 是父组件传递给子组件的 Non-Props，可以直接在 attrs 中进行访问。attrs 和 Props 类型，它是有状态对象。会随组件本身的更新而更新，这意味着应该避免对它们进行解构，并始终以 `attrs.x` 或 `slots.x` 的方式引用 property。\n\n与 `props` 不同的是，`attrs` 和 `slots` 是**非**响应式的。如果打算根据 `attrs` 或 `slots` 更改应用副作用，那么应该在 `onUpdated` 生命周期钩子中执行此操作。\n\n### slots\n\nslots 是父组件传递给子组件的插槽内容，可以直接访问具名插槽。\n\n访问的插槽是一个渲染函数，会直接渲染成虚拟 DOM。还可以直接使用 render 函数来渲染出插槽内容。\n\n```html\n  <!-- 父组件 -->  \n  <HelloWorld msg=\"Hello Vue 3 in CodeSandbox!\"\n    >this is a test.\n    <template #test> oh,test </template>\n  </HelloWorld>\n```\n\n```js\n// 子组件内\nimport { h } from \"vue\";\nexport default {\n  name: \"HelloWorld\",\n  setup(props, { attrs, slots }) {\n    console.log(slots.default());\n    console.log(slots);\n    console.log(attrs);\n    return () => h(\"div\", {}, [slots.default(), slots.test()]);\n  },\n};\n```\n\n相当于`this.$slots`\n\n### emit\n\n相当于`this.$emit`；\n\n## watch\n\nwatch 是惰性的。\n\n对于使用 ref 创建的响应式对象，watch 可以直接进行监听。而对于 reactive 的响应式对象，需要返回一个函数才能正常监听。\n\n```js\n  setup() {\n    const nameObj = reactive({ name: \"\" });\n    const nameHistory = reactive([]);\n    const { name } = toRefs(nameObj);\n    watch(\n      () => nameObj.name,\n      (cur, pre) => {\n        nameHistory.push(pre);\n      }\n    );\n    return {\n      name,\n      nameHistory,\n    };\n  },\n```\n\nwatch 还支持同时监听多个数据的变化，它的两个参数分别都接受数组。不同的是，在回调函数中，参数的顺序是`([第一个当前值, 第二个当前值], [第一个上次值, 第二个上次值])`\n\n```js\n    watch(\n      [() => nameObj.name, () => nameObj.engName],\n      ([curN, curEn], [preN, preEn]) => {\n        console.log([curN, curEn], [preN, preEn]);\n      }\n    );\n```\n\n### watchEffect\n\n为了根据响应式状态*自动应用*和*重新应用*副作用，我们可以使用 `watchEffect` 方法。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。\n\nwatchEffect 是非惰性的\n\n```js\n    watchEffect(() => {\n      console.log(nameObj.name);\n    });\n```\n\n### 停止所有的 watch\n\n两个 watch 方法都返回一个方法，通过调用返回的方法就能够取消监听。\n\n```js\n    const stopWacth = watchEffect(() => {\n      console.log(nameObj.name);\n      setTimeout(() => {\n        stopWacth();\n      }, 5000);\n    });\n```\n\n## 生命周期函数\n\n`setup` 是围绕 `beforeCreate` 和 `created` 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 `setup` 函数中编写。\n\n| 选项式 API        | Hook inside `setup` |\n| ----------------- | ------------------- |\n| `beforeCreate`    | Not needed*         |\n| `created`         | Not needed*         |\n| `beforeMount`     | `onBeforeMount`     |\n| `mounted`         | `onMounted`         |\n| `beforeUpdate`    | `onBeforeUpdate`    |\n| `updated`         | `onUpdated`         |\n| `beforeUnmount`   | `onBeforeUnmount`   |\n| `unmounted`       | `onUnmounted`       |\n| `errorCaptured`   | `onErrorCaptured`   |\n| `renderTracked`   | `onRenderTracked`   |\n| `renderTriggered` | `onRenderTriggered` |\n\n`renderTracked`：每次渲染之后重新手机响应式依赖；\n\n`renderTriggered`：每次触发页面重新渲染时自动执行；\n\n## Composition API 获取 DOM\n\n首先先在 DOM 节点上赋予对应的 ref attr\n\n```html\n<template>\n  <div ref=\"test\"></div>\n</template>\n```\n\n然后在 setup 中使用 ref 方法创建一个空的响应式变量（null），变量名需要与获取的 DOM ref 相同。随后直接 return 该变量。\n\n之后在例如 onMounted 这样的生命周期函数中就能访问到对应的 DOM 元素。\n\n```js\n  setup() {\n    const test = ref(null);\n    onMounted(() => {\n      console.log(test.value);\n    });\n    return {\n      test,\n    };\n  },\n```\n\n[Composition API 获取 DOM](https://codesandbox.io/s/composition-api-huoqu-dom-dgvro)\n\n## 一些练习\n\n* [composition-api-provide-inject](https://codesandbox.io/s/composition-api-provide-inject-kbows)\n* [Composition API 获取 DOM](https://codesandbox.io/s/composition-api-huoqu-dom-dgvro)\n* [composition-api ToDoList](https://codesandbox.io/s/composition-api-todolist-f1fv4)","desc":"早期学习 Vue3 API 的笔记。\n\nsetup\n\nsetup 方法在实例被创建（created）之前。\n\nref\n\n直接在 setup 中定义变量无法自动成为响应式，需要使用 ref 将其通过 p...","title":"Vue3!","date":"2021-05-05T18:08:31.000Z","tags":"Vue","categories":"实践","url":"vue3-notes","index_img":null}},"__N_SSG":true}