{"pageProps":{"postData":{"id":"javascript-object-oriented-programming","content":"\n> Standing on Shoulders of Giants.\n>\n> 本篇参考与《JavaScript高级程序设计》第六章：面向对象的程序设计。\n\n面向对象（Object-Oriented，OO）的语言都有一个标志，那就是他们都有类的概念。通过类来创建任意多个具有相同属性和方法的对象。\n\nECMAScript中没有类的概念，所以它的对象也与基于类的语言中的对象有所不同。\n\nECMAScript-262的对象定义为：“无序属性的集合，其属性可以是基本值、对象和函数。”也就是说对象是一个没有属性的键值映射对，其值可以是数据和函数。\n\n![logo](../images/JavaScript面向对象的程序设计/logo.webp)\n\n## 属性类型\n\n虽然在JavaScript中不能直接访问属性类型，但是为了表示特性是内部值，ECMA-262将其放在了两对方括号中。\n\n**ECMAScript中有两种属性：数据属性和访问器类型属性。**\n\n* [[Configurable]]：表示能否通过delete删除属性从而定义属性，能否修改属性特性，或者能否把属性修改为访问器属性。默认为true\n* [[Enumerable]]：表示能否通过for-in循环返回属性。默认为true\n* [[Writable]]：表示能否修改属性的值。默认为true\n* [[Value]]：包含这个属性的数据值。读取属性的时候从这个位置读取，写入属性值的时候把新值保存在这个位置。默认值为undefined\n\n使用对象字面量创建一个对象时，上述四个特性都为true。value则为属性的值。\n\n### 修改属性的默认特性\n\n要修改默认的特性必须要使用ECMAScritpt5的`Object.prototype.defineProperty()`方法。\n\nSyntax：\n\n```js\nObject.defineProperty(obj, prop, descriptor)\n```\n\n```js\nlet obj = {\n    name: 'xfy',\n    age: 18,\n    saySomthing: function () {\n        console.log(this.name);\n    }\n}\nObject.defineProperty(obj, 'name', {\n    writable: false,\n    value: 'xxxxfy',\n    configurable: false\n})\n```\n\n> 将configurable修改为false之后就无法再进行配置了，也就说无法再修改回来了。其他特性都是可以再修改的。\n\n### 访问器属性\n\n为对象设置一个访问器的属性，这个属性不包含数据值，它包含一对setter和getter函数（不是必需的）。在读取这个访问器属性时，会调用getter函数。在写入这个访问器属性时，会调用setter函数。setter决定了如何处理数据。\n\n访问器属性具有如下4个值：\n\n* [[Configurable]]：表示能否通过delete删除属性从而定义属性，能否修改属性特性，或者能否把属性修改为访问器属性。默认为true\n* [[Enumerable]]：表示能否通过for-in循环返回属性。默认为true\n* [[Get]]：在读取属性时调用的函数。默认为undefined\n* [[Set]]：在写入属性时调用的函数。默认为undefined\n\n访问器属性不能直接定义，必须使用`Object.defineProperty()`方法来定义。\n\n```js\nlet arr = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];\nlet xbox = {\n    _name: 'xbox ',\n    _year: 2020,\n    edition: arr[1],\n    name: function () {\n        return this._name + this.edition;\n    }\n}\nconsole.log(xbox.name());\nObject.defineProperty(xbox, 'year', {\n    get: function () {\n        // 返回对象方法访问的属性\n        return this._year;\n    },\n    set: function (value) {\n        // 值不小于2020且不大于2030（因为数组就10个🤣）\n        if (!(value < 2020) && !(value > 2030)) {\n            // 根据值判断版本，并在数组取值\n            this.edition = arr[value - this._year + 1];\n            // 将属性访问的方法同时也设置\n            this._year = value;\n        }\n    }\n})\nxbox.year = 2021;\nconsole.log(xbox.year);\nconsole.log(xbox.name());\n\n// PlayStation？\nlet ps = {\n    _name: 'PlayStation ',\n    _year: 2020,\n    edition: 4,\n    name: function () {\n        return this._name + this.edition;\n    }\n}\nObject.defineProperty(ps, 'year', {\n    get: function () {\n        // 返回对象方法访问的属性\n        return this._year;\n    },\n    set: function (value) {\n        // 值不小于2020且不大于2030（xbox也10个🤣）\n        if (!(value < 2020) && !(value > 2030)) {\n            // 根据值判断版本，并加上基础版本：4\n            this.edition = value - this._year + 4;\n            // 将属性访问的方法同时也设置\n            this._year = value;\n        }\n    }\n})\nps.year = 2021\nconsole.log(ps.name());\n```\n\n访问器属性还有一个能够同时定义多个属性的方法。与单个定义对象相同，唯一区别是这里的属性都是同一时间创建的。\n\n```js\n// 同时定义多个属性\nlet ps = {};\nObject.defineProperties(ps, {\n    _name: {\n        value: 'PlayStation',\n        writable: true,\n        configurable: true\n    },\n    _year: {\n        value: 2020,\n        writable: true,\n        configurable: true\n    },\n    edition: {\n        value: 4,\n        writable: true,\n        configurable: true\n    },\n    name: {\n        value: function () {\n            return this._name + ' ' + this.edition;\n        },\n        writable: true,\n        configurable: true\n    },\n    year: {\n        get: function () {\n            return this._year;\n        },\n        set: function (value) {\n            if (!(value < 2020) && !(value > 2030)) {\n                this.edition = value - this._year + 4;\n                this._year = value;\n            }\n        }\n    }\n})\n```\n\n### 读取属性的特性\n\n属性的特性可以很方便的设置，当然也可以方便的读取。使用ECMAScript5的`Object.getOwnPropertyDescriptor()`方法就可以读取属性的特性。\n\n继上述案例：\n\n```js\nObject.getOwnPropertyDescriptor(ps, 'year');\n// 输出：\n// configurable: false\n// enumerable: false\n// get: function get()\n// set: function set(value)\n// <prototype>: Object { … }\n```\n\n可以详细的看到属性的特性。\n\n```js\nObject.getOwnPropertyDescriptor(ps, '_year').value\n// 2021\n```\n\n> 在JavaScript中可以针对任何对象--包括DOM和BOM对象使用`Object.getOwnPropertyDescriptor()`方法。\n\n## 创建对象\n\n使用Object构造函数和对象字面量可以用来创建单个对象。但是这些方法都不能使用同一个接口创建大量的对象。\n\n### 工厂模式\n\n工厂模式应该是软件设计领域中一种广为人知的设计模式。但是在ECMAScript中无法创建类，早期的人们使用一种函数，来封装以特定接口创建对象的细节。\n\n```js\nfunction createOne(name, age, sex) {\n    let o = {};\n    o.name = name;\n    o.age = age;\n    o.sex = sex;\n    o.say = function () {\n        console.log(this.name);\n    }\n    return o;\n}\nlet person1 = createOne('xfy', 18, 'male');\nlet person2 = createOne('dfy', 81, 'female');\nconsole.log(person1);\nconsole.log(person2);\n```\n\n工厂模式在函数内显式的创建一个空对象，然后让函数的参数传为对象属性。最后返回函数。这样就可以多次调用这个函数来创建多个相似对象。但这样却无法解决对象试别的问题。\n\n### 构造函数\n\n像`Object()`和`Array()`都是原生的构造函数。在现在，可以创建自定义的构造函数，从而自定义对象类型的属性和方法。\n\n重写上述工厂模式：\n\n```js\nfunction One(name, age, sex) {\n    this.name = name;\n    this.age = age;\n    this.sex = sex;\n}\nlet person1 = new One('xfy', 18, 'female');\nlet person2 = new One('dfy', 81, 'male');\nconsole.log(person1);\nconsole.log(person2);\n```\n\n使用构造函数创建对象必须使用new操作符。此外构造函数的函数名通常为首字母大写，非构造函数首字母小写。这个做法借鉴自其他OO语言。\n\n使用构造函数创建的对象，constructor都指向这个构造函数。\n\n```js\nconsole.log(person1.constructor);\t// function One(name, age, sex) { … }\n```\n\n这就是构造函数胜过工厂模式的一个地方，工厂模式无法将其实例标记为一种特定的类型。在工厂模式下创建的实例，constructor都将指向`Object()`这个构造函数，因为工厂模式返回的对象是显式创建的，它继承自Object。\n\n#### 内部原理\n\n```js\nfunction Make() {\n    this.name = 'xfy';\n}\n```\n\n一个构造函数在生成时使用`new`操作符，此时的函数内部隐式的声明了一个对象：\n\n```js\nfunction Make() {\n    // this = {};\n    this.name = 'xfy';\n}\n```\n\n有了this这个对象之后，函数的作用域赋给新对象（所以this指向了这个对象）：\n\n```js\nfunction Make() {\n    // this = {\n    \t// name : 'xfy'\n\t// };\n    this.name = 'xfy';\n}\n```\n\n最后再隐式的return this：\n\n```js\nfunction Make() {\n    // this = {\n    \t// name : 'xfy'\n\t// };\n    this.name = 'xfy';\n    // return this;\n}\n```\n\n总结四步：\n\n1. 隐式的创建一个新对象；\n2. 将构造函数的作用域赋值给新对象（this指向）；\n3. 执行构造函数内的代码（添加属性）；\n4. 返回新对象；\n\n也就是说可以不使用`new`来使用一个构造函数（工厂模式）：\n\n```js\nfunction Xfy() {\n    let that = {};\n    that.name = 'xfy';\n    that.age = 18;\n    return that;\n}\nlet xfy = Xfy();\n```\n\n不赋值给一个对象，直接返回执行的结果：\n\n```js\nnew Person().say();\n```\n\n若给构造函数显示的返回了一个空对象，则显示的返回优先级高于隐式的返回结果：\n\n```js\nfunction Make() {\n    this.name = 'xfy';\n    return {};\n}\n```\n\n但是如果显示的返回不是对象值，而是一个基本值，则构造函数不会收到影响：\n\n```js\nfunction Make() {\n    this.name = 'xfy';\n    return 123;  // 不受影响\n}\n```\n\n#### 普通函数\n\n构造函数也是函数，它也能当作普通函数来使用。在全局作用域下，直接使用构造函数将会使其this指向全局对象。\n\n```js\nfunction One(name, age, sex) {\n    this.name = name;\n    this.age = age;\n    this.sex = sex;\n}\nOne('xfy');\nwindow.name\n// \"xfy\"\n```\n\n所以可以将构造函数使用call/apply来调用：\n\n```js\nlet obj = {};\nOne.call(obj, 'xfy', 18, 'female');\nconsole.log(obj);\n```\n\n那么自然多个构造函数也可以互相利用，使用call/apply来改变调用函数的this为当前构造函数的this就可以利用上已经写过的代码。\n\n```js\nfunction Two(name, age, sex, say) {\n    One.call(this, name, age, sex);\n    this.say = function () {\n        console.log(say);\n    }\n}\nlet two = new Two('xfy', 18, 'female', '嘤嘤嘤');\nconsole.log(two.say());\n```\n\n### 构造函数的问题\n\n构造函数虽然好用，但也并非没有缺点。构造函数的主要问题就是每个方法都要在实例上重新创建一遍。\n\n```js\nfunction Two(name, age, sex, say) {\n    One.call(this, name, age, sex);\n    this.say = function () {\n        console.log(say);\n    }\n    // this.say = new Function('console.log(say)')\n}\nlet two = new Two('xfy', 18, 'female', '嘤嘤嘤');\nlet two1 = new Two('xfy', 18, 'female', '咕咕咕');\nconsole.log(two.say === two1.say);\n```\n\n继上述例子中，每个构造函数内都包含一个不同的Function实例。以这种方式创建函数，会导致不同的作用域链和标识解析符。但创建Function新实例的机制任然是相同的。所以导致由构造函数创建的实例的方法只是同名而不相等。\n\n```js\nconsole.log(two.say === two1.say);\t// false\n```\n\n创建这样两个完成相同任务的Function实例根本没有必要；况且有this对象存在，根本不用在执行代码前就把函数绑定到特定的对象上面。\n\n所以可以考虑将特定的方法转移出构造函数内部来解决这个问题\n\n```js\nfunction Two(name, age, sex, say) {\n    One.call(this, name, age, sex);\n    this.say = say;\n    this.saySome = saySome;\n}\nlet two = new Two('xfy', 18, 'female', '嘤嘤嘤');\nlet two1 = new Two('xfy', 18, 'female', '咕咕咕');\nconsole.log(two.saySome);\n\nfunction saySome() {\n    console.log(this.say);\n}\n```\n\n在构造函数的内部将方法指定为外部的全局函数，这样saySome包含的是一个函数的指针，因此创建出的对象的方法就共享了在全局作用域中定义的同一个函数。这样就能解决两个函数做同一件事的问题。当然这样还无法解决所有问题，如果对象需要很多的方法，那么就需要在全局作用域定义很多的函数，于是这个自定义的引用类型就毫无封装性可言了。\n\n好在，原型模式可以帮我们解决这些问题。\n\n## 原型\n\n每创建一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象。这个对象的好处就在于可以包含特定类型的所有实例共享的方法和属性。也就是说，构造函数的prototype（原型）这个对象的属性，可以包含到所有由这个构造函数创建的实例上。\n\n这样，上述出现的全局函数不需要去污染全局环境，可以定义在原型上。另外，一些固有的属性也可以直接放在原型上。\n\n```js\nTwo.prototype.name = 'xfy';\nTwo.prototype.age = 18;\nTwo.prototype.saySome = function () {\n    console.log(this.say);\n}\n\nfunction Two(sex, say) {\n    this.sex = sex;\n    this.say = say;\n}\nlet two = new Two('female', '嘤嘤嘤');\nlet two1 = new Two('male', '咕咕咕');\nconsole.log(two.saySome);\n```\n\n### 理解原型对象\n\n无论在何时，只要创建了一个新的函数，就会根据一组特定规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，原型对象会自动获得一个constructor属性。这个属性指向prototype属性所在函数的指针。也就是说指向构造函数本身`Two.prototype.constructor = Two`。\n\n创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性。其他的方法都是由Object继承而来。当使用构造函数创建新实例后，这个实例会包含一个指针（内部属性），指向构造函数的原型。ECMA-262第5版管这个指针叫做[[Prototype]]。虽然在js中没有标准访问[[Prototype]]的方法。但在多数浏览器中都支持一个属性：`__proto__`。\n\n不过真正要明确的是，这个连接只存在与实例与构造函数的原型对象之间，而不存在与实例与构造函数之间。\n\n```js\n(Two Prototype)\nTwo.prototype --> Two.prototype\ntwo1.__proto__ --> Two.prototype\n```\n\n所有在原型上的属性与方法都能被创建的实例所调用。这是通过查找对象属性的过程来实现的。就和作用域链类似，在实例上没有找到的属性会继续向上至原型链查找。\n\n有两种方法来检测/访问到实例的原型对象：`isPrototypeOf()`和`Object.getPrototypeOf()`。\n\n* `isPrototypeOf()`用来检测函数是否是实例的原型；\n* `Object.getPrototypeOf()`返回的就是实例的原型；\n\n```js\nconsole.log(Two.prototype.isPrototypeOf(two));\nconsole.log(Object.getPrototypeOf(two) == Two.prototype);\n```\n\n> constructor属性也是共享的，可以通过实例对象访问。\n\n### 无法重写\n\n实例无法重写原型上的属性。虽然对象实例可以访问原型，但是对于原型上的属性的增、删操作都是不可以的。如果对象实例上设置了一个和原型属性同名的属性，那么就会优先访问实例本身的属性。\n\n```js\nTwo.prototype.name = 'xfy';\nTwo.prototype.age = 18;\nTwo.prototype.saySome = function () {\n    console.log(this.say);\n}\nfunction Two(sex, say) {\n    this.sex = sex;\n    this.say = say;\n}\nlet two = new Two('female', '嘤嘤嘤');\nlet two1 = new Two('male', '咕咕咕');\ntwo.name = 'dfy';\nconsole.log(two.name);\t// dfy\nconsole.log(two1.name);\t// xfy\n```\n\n就相当于屏蔽了实例去访问原型上的同名属性，即使将实例本身的属性设置为null也不会恢复其指向原型的连接。不过使用delete操作符删除这个属性后，就能重新访问原型上的属性。\n\n```js\ntwo.name = 'dfy';\nconsole.log(two.name);\t// dfy\ndelete two.name;\nconsole.log(two.name);\t// xfy\n```\n\n当然它也有检测的方法：`hasOwnProperty()`。\n\n```js\ntwo.name = 'dfy';\nconsole.log(two.hasOwnProperty('name'));\t// true\ndelete two.name;\nconsole.log(two.hasOwnProperty('name'));\t// false\n```\n\n### in操作符\n\nin操作符可以单独使用和在for-in循环中使用。在单独使用时，in用于检测给定的属性通过对象能否访问，无论是继承还是自有属性。\n\n```js\nconsole.log('saySome' in two);\n```\n\n配合`hasOwnProperty()`来使用就能检测属性是否是继承来的。\n\n```js\nfunction inheritProperty(target, prep) {\n    return !target.hasOwnProperty(prep) && (prep in target);\t// 不是自有属性，同时能够访问\n}\n```\n\nfor-in循环会便利所有能访问、可枚举(enumerated)的属性。无论是否是继承来的属性。另外，屏蔽了原型中不能枚举的实例属性也能在for-in循环中返回。因为根据规定，所有开发人员定义的属性都是可枚举的。（只有IE8及更早的版本除外）\n\n这里的two实例重写了`toString()`方法，可以被for-in循环遍历出来。\n\n![image-20200726171729248](../images/JavaScript面向对象的程序设计/image-20200726171729248.webp)\n\n若要更方便的取出实例的自有属性，可以使用`Object.keys()`方法。它会返回所有自有的可枚举的属性。返回结果为一个数组，出现顺序与for-in循环相同。\n\n```js\nObject.keys(two)\n// Array(3) [ \"sex\", \"say\", \"toString\" ]\n```\n\n可以使用`Object.getOwnPropertyNames()`来访问所有属性，包括不可枚举的属性\n\n```js\nObject.getOwnPropertyNames(Two.prototype)\n// vArray(4) [ \"constructor\", \"name\", \"age\", \"saySome\" ]\n```\n\n### 更简单的原型语法\n\n前面给原型添加属性都是一行一行的写的，每添加一个属性都要`Two.prototype`一遍。为了减少输入，常见的做法是使用对象字面量来重写整个原型对象。\n\n```js\nTwo.prototype = {\n    name: 'xfy',\n    age: 18,\n    saySome: function () {\n        console.log(this.say);\n    }\n}\n```\n\n将构造函数的prototype以对象字面量形式重新创建一个对象。最终结果没有任何变化，除了constructor不在指向这个构造函数以外。因为重写了prototype，所有constructor也就不存在了。\n\n可以手动将constructor设置为正确是值，但此时的constructor就会变为可枚举的属性。在支持ECMAScript5的环境下，可以再手动设置为不可枚举的属性。\n\n```js\nTwo.prototype = {\n    name: 'xfy',\n    age: 18,\n    saySome: function () {\n        console.log(this.say);\n    }\n}\nObject.defineProperty(Two.prototype, 'constructor', {\n    enumerable: false,\n    value: Two\n})\n```\n\n### 原型的动态性\n\n由于在原型中查找值的过程是一次搜索，所以可以随时的修改原型的属性，并立即的在实例上反应出来。即使是先创建了实例再修改的原型也是如此。\n\n实例与原型之间的连接不过是一个指针，而非一个副本。因此在后面的语句中可以找到新的属性。\n\n```js\nTwo.prototype = {\n    name: 'xfy',\n    age: 18,\n    saySome: function () {\n        console.log(this.say);\n    }\n}\nObject.defineProperty(Two.prototype, 'constructor', {\n    enumerable: false,\n    value: Two\n})\n\nfunction Two(sex, say) {\n    this.sex = sex;\n    this.say = say;\n}\nlet two = new Two('female', '嘤嘤嘤');\nlet two1 = new Two('male', '咕咕咕');\n\nconsole.log(two.name);\nTwo.prototype.name = 'xxxfy';\nconsole.log(two.name);\n```\n\n尽管原型可以随时的修改属性和方法，并且能够在所有对象实例中立即反应出来。但是如果重写整个原型对象，那么情况就不一样了。\n\n在调用构造函数时会为实例添加一个**指向最初原型**的[[prototype]]指针，而重写整个原型对象之后，就相当于切断了构造函数与最初原型之间的联系。实例中的指向仅指向原型，而不指向构造函数。\n\n所以在实例之后重写整个原型并不会生效，且**实例的指针还是指向最初的原型**。\n\n```js\nTwo.prototype.name = 'xxxfy';\n\nfunction Two(sex, say) {\n    this.sex = sex;\n    this.say = say;\n}\nlet two = new Two('female', '嘤嘤嘤');\nlet two1 = new Two('male', '咕咕咕');\n\nconsole.log(two.name);\t// xxxfy\nconsole.log(two.constructor);\n\nTwo.prototype = {\n    name: 'xfy',\n    age: 18,\n    saySome: function () {\n        console.log(this.say);\n    }\n}\nObject.defineProperty(Two.prototype, 'constructor', {\n    enumerable: false,\n    value: Two\n})\n```\n\n### 原生对象的原型\n\n毫不意外的，原生的引用类似也是采用这种模式。可以像修改自定义对象的原型一样修改原生对象的原型。\n\n由于声明了一个字符串变量，那么后台就会自动调用String来基本包装这个字符串，因此str这个变量可以直接调用String原型上的方法。\n\n```js\nString.prototype.yyy = function () {\n    return '嘤嘤嘤';\n}\nlet str = 'xfy';\nconsole.log(str.yyy());\n```\n\n原生对象的原型是可以被重写的。\n\n### 原型对象的问题\n\n原型虽然很大程度上解决了很多问题，但它也是有缺点的。首先它省略了为构造函数传递初始化参数这一环节，导致了所有实例再默认情况下都将取得相同的属性值。但这并不是主要问题，主要问题还是其共享性的特征导致的。\n\n对于函数来说，这种共享性特别合适。对于包含基本值的属性也还行。但是对于引用值来说，就有很大的问题了。\n\n通过该构造函数创建的两个实例，当一个实例修改了原型上的引用值时，另一个实例也被一起更改。\n\n```js\nfunction Person() {\n\n}\nPerson.prototype = {\n    name: 'xfy',\n    age: 18,\n    job: null,\n    consoles: ['xbox', 'playstation'],\n    sayName: function () {\n        console.log(this.name);\n    }\n}\nObject.defineProperty(Person.prototype, 'constructor', {\n    enumerable: false,\n    value: Person\n})\n\nlet xfy = new Person();\nlet dfy = new Person();\n\nxfy.consoles.push('nintendo');\nconsole.log(xfy.consoles);\nconsole.log(dfy.consoles);\n```\n\n### 组合使用构造函数与原型\n\n在了解构造函数的时候，了解到一个问题所在就是构造函数的每个属性/方法对于每个实例都是重新创建的。而原型则有着共享性。所以将二者组合使用就能互补其缺点。\n\n这种方法的使用，每个实例就有自己的一份实例属性副本，但是同时又共享着对方法的引用，最大限度的节省了内存。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.consoles = ['xbox', 'playstation'];\n}\nPerson.prototype = {\n    sayName: function () {\n        console.log(this.name);\n    }\n}\nObject.defineProperty(Person.prototype, 'constructor', {\n    enumerable: false,\n    value: Person\n})\n\nlet xfy = new Person();\nlet dfy = new Person();\n\nxfy.consoles.push('nintendo');\nconsole.log(xfy.consoles);\t// [ \"xbox\", \"playstation\", \"nintendo\" ]\nconsole.log(dfy.consoles);\t// [ \"xbox\", \"playstation\" ]\n```\n\n### 动添原型模式\n\n原型的动态性把所有信息都封装在了构造函数中。这样可以在构造函数中初始化原型（必要情况下），又保持了原型和构造函数的优点。也就是说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。\n\n对于这种模式创建的对象，还可以是使用`instanceof`来确定它的类型。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.consoles = ['xbox', 'playstation'];\n    if (typeof(sayName) != 'function') {\n        Person.prototype.sayName = function () {\n            console.log(this.name);\n        }\n    }\n}\n\nlet xfy = new Person('xfy', 18, null);\nlet dfy = new Person();\n\nxfy.consoles.push('nintendo');\nxfy.sayName();\n```\n\n> 如果在已经创建了实例的情况下重写原型，则会切断实例与新原型的联系。\n\n### 寄生构造函数模式\n\n在前面几种模式都不适用的情况下，可以适用寄生(parasitic)构造函数模式。在这个模式下会新建一个对象，并以相应的属性和方法初始化该对象，最后返回该对象。除了使用new操作符之外，这个模式与工厂模式一模一样。\n\n构造函数在不返回值的情况下，默认会返回新对象实例。而在构造函数末尾添加一个return语句，可以重写调用构造函数时返回的语句。\n\n这个模式可以用在特殊的情况下为对象创建构造函数。如果需要一个具有额外方法的特殊数组，而且不能直接Array构造函数，可以使用这个模式。\n\n在这个模式下返回的对象与构造函数的原型直接没有任何关系。构造函数返回的对象与外部创建的对象没有任何的不同。无法用instanceof来确定对象类型。\n\n```js\nfunction myArray() {\n    // 创建一个数组\n    let val = new Array();\n    // 将参数全部传递进去\n    val.push.apply(val, arguments);\n    // 自定义一个方法\n    val.pid = function () {\n        return val.join('|');\n    }\n    return val\n}\nlet arr = new myArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);\nconsole.log(arr.pid());\n```\n\n### 稳妥构造函数模式\n\n所谓稳妥对象，指的是没有公共属性，而且其方法也不能引用this的对象。稳妥对象最时候在一些安全的环境中（禁用this和new的环境）使用。\n\n稳妥与寄生构造函数类似，但有两点不同：\n\n1. 创建新对象的实例方法不引用this；\n2. 不适用new操作符调用构造函数；\n\n除了调用定义的方法外，没有其他方法去访问传递的参数。\n\n```js\nfunction Person(name, age) {\n    let o = new Object();\n    o.sayName = function () {\n        console.log(name);\n    }\n    o.sayAge = function () {\n        console.log(age);\n    }\n    return o;\n}\n\nlet xfy = Person('yyy', 18);\nconsole.log(xfy.name);\nxfy.sayName();\n```\n\n它和私有化变量也很相似，同样的也是不引用this和不使用new操作符。\n\n> 它也和寄生构造函数一样，与构造函数的原型没有多大关系，也无法通过instanceof来确定类型。\n\n## 私有化变量\n\n闭包的另一种应用，在构造函数上的应用。\n\n在使用构造函数构造对象时，属性中的函数会向闭包一样返回为对象的功能，因为闭包的特征，所以构造函数中AO中的变量能被属性内的函数保存和读取。\n\n而构造函数中创建的变量不能使用通常的方法被对象直接访问，只有对象调用指定的方法才能访问。\n\n```js\nfunction Xfy(name, consoled) {\n    let anotherConsole = 'ps4';\n    this.name = name;\n    this.consoled = consoled;\n    this.changeConsole = function () {\n        this.console = anotherConsole;\n    }\n    this.buyConsole = function (target) {\n        anotherConsole = target;\n    }\n    this.sayTrueth = function () {\n        console.log(anotherConsole);\n    }\n}\nlet xfy = new Xfy('xfy', 'xbox');\n```\n\n> console.log中的console也是关键字，和变量等不能重名……\n\n## 继承\n\n继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于JS的函数没有签名，所有无法实现接口继承，只有实现继承。而实现继承主要依靠的是原型链。\n\n### 原型链\n\nECMAScript中描述的原型链的概念，并将原型链作为实现继承的主要方法。其基本思想就是让一个引用类型继承另一个引用类型的属性和方法。\n\n构造函数和原型与实例的关系：每个构造函数都一个原型对象，原型对象都包含一个指向构造函数的指针。而实例都包含一个指向原型对象的内部指针。\n\n如果让构造函数的原型对象等于另一个类型的实例，另一个原型也包含另一个构造函数的指针，如果另一个原型又是另一个类型的实例，那么原型的关系就会层层递进，呈链式结构。这就是原型链的基本概念。\n\n```js\nfunction SuperType() {\n    // 为实例设置属性\n    this.property = true;\n}\n// 在原型上添加一个方法，通过该构造函数创建的实例就会有该方法。\nSuperType.prototype.getProperty = function() {\n    console.log(this.property);\n}\n\nfunction SubType() {\n\n}\n// 将次级构造函数的原型对象设置为上级构造函数的实例。上级构造函数的实例包含其原型对象，将其设置到该构造函数的原型对象上。\nSubType.prototype = new SuperType();\n\n// 通过该构造函数创建的实例就会继承最高级构造函数的原型对象。\nlet xfy = new SubType();\nxfy.getProperty();  // true\n```\n\n由于SubType的原型对象是SuperType的实例，相当于重写了SubType的原型对象，所以通过SubType创建的实例对象的constructor指向的是SuperType。\n\n```js\nxfy instanceof SubType;\n// true\nxfy instanceof SuperType;\n// true\nxfy.constructor;\n// function SuperType()\n```\n\n### 默认原型\n\n所有引用类型都继承了Object，这个继承也是通过原型链来实现的。**所有函数的默认原型都是Object的实例**，因此默认原型都会包含一个内部指针，指向Object.prototype。这也就是所有自定义类型都会继承`toString()`、`valueOf()`等方法的根本原因。\n\n```js\nString instanceof Object;\t// true\n```\n\n### 确定原型与实例的关系\n\n可以使用instanceof，instanceof用于检测该对象的原型链中有没有该函数的原型。\n\n```js\nString instanceof Object;\t// true\nSuperType instanceof Object;\t// true\nxfy instanceof SubType;\t\t// true\nxfy instanceof SuperType;\t// true\nxfy instanceof Object;\t\t// true\n```\n\n`isPrototypeOf()`方法与instanceof类似，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。\n\n```js\nObject.prototype.isPrototypeOf(xfy);\t// true\nSuperType.prototype.isPrototypeOf(xfy);\t// true\nSubType.prototype.isPrototypeOf(xfy);\t// true\n```\n\n### 谨慎的定义方法\n\n在原型链中，如果给子类型添加一个与超类型的同名的方法，那么子类型的实例就会继承覆盖超类型的方法。\n\n```js\nfunction SuperType() {\n    this.property = true;\n}\nSuperType.prototype.getProperty = function() {\n    console.log(this.property);\n}\n\nfunction SubType() {\n\n}\nSubType.prototype = new SuperType();\nSubType.prototype.getProperty = function() {\n    return false;\n}\n\nlet xfy = new SubType();\nxfy.getProperty();  // false\n```\n\n此外，重写原型链的方法时，不能使用对象字面量的方法来创建方法。这样会切断刚刚创建的原型链的联系。\n\n```js\nfunction SuperType() {\n    this.property = true;\n}\nSuperType.prototype.getProperty = function() {\n    console.log(this.property);\n}\n\nfunction SubType() {\n\n}\nSubType.prototype = new SuperType();\nSubType.prototype = {\n    getProperty: function () {\n        return false;\n    }\n}\n\nlet xfy = new SubType();\nxfy.property // undefined\n```\n\n### 原型链的问题\n\n原型链和原型一样非常的强大，但是它也有和原型一样的问题。那就是对引用值的问题。\n\n修改子类型任何一个实例原型上的值，都是对`SubType.prototype`这个原型对象的修改。并且会实时的反应到SubType创建的实例上去。\n\n```js\nfunction SuperType() {\n    this.arr = [1, 2, 3, 4, 5];\n    this.property = true;\n}\nSuperType.prototype.getProperty = function () {\n    console.log(this.property);\n}\n\nfunction SubType() {\n\n}\nSubType.prototype = new SuperType();\n\n\nlet xfy = new SubType();\nlet dfy = new SubType();\nconsole.log(xfy.arr);\t// [1, 2, 3, 4, 5]\nconsole.log(dfy.arr);\t// [1, 2, 3, 4, 5]\n\n// 修改子类型任何一个实例原型上的值\ndfy.arr.push(6, 7, 8, 9)\n\nconsole.log(xfy.arr);\t// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nconsole.log(dfy.arr);\t// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nconsole.log(SubType.prototype.arr);\t// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n```\n\n除此之外，原型链创建实例还有另外一个问题。在子类创建实例时无法向超类传递参数。实际上，无法在布影响所有对象实例的情况下，给超类的构造函数传递参数。\n\n### 借用构造函数\n\n原型链中所出现的问题可以配合构造函数使用来解决。这种方法称之为（constructor stealing）有时候也称为伪造对象或经典继承。\n\n这种思想非常简单，即在子类型构造函数的内部调用超类型的构造函数。函数只不过是在特定环境中执行代码的对象，通过使用apply/call来调用另个构造函数也可以创建实例。\n\n当然为了确保没有重写子类型的属性，可以先调用超类型的构造函数，在其后添加自定义属性。\n\n这样创建出的实例就会有自己的属性副本了，而不是从原型链上继承得来的。所以修改其他实例的属性就不会影响到原型链，也就不会影响到其他实例了。\n\n```js\nfunction SuperType(name, age) {\n    this.name = name;\n    this.age = age;\n    this.arr = [1, 2, 3, 4, 5];\n}\n\nfunction SubType(name, age) {\n    // 可以称之为继承自SuperType\n    // 同时还能传递参数\n    SuperType.call(this, name, age);\n}\n\nlet xfy = new SubType('xfy', 18);\nlet dfy = new SubType('dfy', 188);\n\nconsole.log(xfy);\n\nxfy.arr.push(6, 7, 8, 9);\n\nconsole.log(xfy.arr);\t// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\nconsole.log(dfy.arr);\t// [ 1, 2, 3, 4, 5 ]\n```\n\n不过借用构造函数也有问题，就和构造函数本身的问题一样，无法解决函数复用的问题。\n\n### 组合继承\n\n组合继承，有时候也称之为伪继承。指的是将原型链和构造函数的技术结合使用，从而发挥二者之长的一种模式。\n\n这种方法将实例的属性通过借用构造函数来实现继承，让实例都有自己的属性副本，而不是在原型链上。为了解决方法能够复用的问题，将方法定义在原型链上，并通过原型链来继承。\n\n组合继承避免了原型链和构造函数的缺点，融合了它们的优点。而且`instanceof`和`isPrototypeOf()`也能够识别基于组合继承创建的对象。\n\n```js\nfunction SuperType(name, age) {\n    this.name = name;\n    this.age = age;\n    this.arr = [1, 2, 3, 4, 5];\n}\nSuperType.prototype.sayName = function () {\n    console.log(this.name);\n}\n\nfunction SubType(name, age) {\n    // 借用构造函数继承属性\n    SuperType.call(this, name, age);\n}\n// 原型链继承方法\nSubType.prototype = new SuperType;\n\nlet xfy = new SubType('xfy', 18);\nlet dfy = new SubType('dfy', 188);\n\nconsole.log(xfy.sayName());\n\nxfy.arr.push(6, 7, 8, 9);\n\nconsole.log(xfy.arr);\nconsole.log(dfy.arr);\n```\n\n### 原型式继承\n\n道格拉斯·克罗克在06年写了一篇题为Prototypal Inheritance in JavaScript（JavaScript中的原型式继承）的文章。他介绍了一种实现继承的方法。这种方法没有使用严格意义上的构造函数，他的想法是借助原型可以基于**已有的对象创建对象**，同时还不必因此创建自定义类型。\n\n在object函数内部先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时构造函数的一个新实例。从本质上来说，对传入的构造函数进行了一次浅复制。\n\n```js\nfunction object(o) {\n    function F() {};\n    F.prototype = o;\n    return new F();\n}\n```\n\nECMAScript5通过新增`Object.create()`规范化了原型式继承。并且它接受两个参数：\n\n1. 作为新对象原型的对象；\n2. 为新对象定义额外属性的对象；\n\n第二个参数与`Object.defineProperties()`方法的第二个参数格式相同：每个属性都是通过自己的描述符定义了。以这种方式指定的属性都会覆盖原型对象上的同名属性。\n\n```js\nlet one = {\n    name: 'xfy',\n    age: 18\n}\nlet two = Object.create(one, {\n    name: {\n        configurable: false,\n        value: 'dfy'\n    }\n})\n\ntwo.name = 123;\nconsole.log(two.name);\nconsole.log(two.age);\t// 18\n```\n\n### 寄生式继承\n\n寄生式继承式与原型式继承紧密相关的一种思路。它也是用克罗克福德推广而之的。寄生式继承的思路和寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后在真的像它做了所有工作一样返回对象。\n\n基于寄生式继承的对象，不仅仅有了继承的对象属性方法，而且还有自己自定义的方法。\n\n```js\nlet person = {\n    name: 'xfy',\n    age: 18\n}\nfunction test(target) {\n    let clone = Object.create(target);\n    clone.hello = function () {\n        console.log('hi(｡･∀･)ﾉﾞ');\n    }\n    return clone;\n}\nlet xfy = new test(person);\n\nconsole.log(xfy.name);\nconsole.log(xfy.hello());\n```\n\n> 这种方法同样不能做到复用函数。\n\n### 寄生组合继承\n\n组合继承式一个常用的继承模式，不过它也有自己的不足。那就是无论在什么情况下，它都需要调用两次超类型的构造函数。\n\n```js\nfunction SubType(name, age) {\n    // 借用构造函数继承属性\n    SuperType.call(this, name, age);\n}\n// 原型链继承方法\nSubType.prototype = new SuperType;\n```\n\n调用两次超类型构造函数就会导致同样的属性和方法会分别出现在子类型的prototype上和子类型创建的实例上。\n\n寄生组合继承便可以解决这个问题：\n\n```js\nfunction inherit(subtype, supertype) {\n    let prototype = Object.create(supertype.prototype);\n    prototype.constructor = subtype;\n    subtype.prototype = prototype;\n}\n\nfunction One(name) {\n    this.name = name;\n}\nOne.prototype.sayName = function () {\n    console.log(this.name);\n}\n\nfunction Two(name, age) {\n    One.call(this, name);\n    this.age = age;\n}\nTwo.prototype.sayAge = function () {\n    console.log(this.age);\n}\n\ninherit(Two, One);\n\nlet xfy = new Two('xfy', 18);\n\nconsole.log(xfy.name);\n```\n\n这种方法解决了多次调用超类型函数，已经在子类型原型上创建多余不必要的属性。同时原型链还能保持不变。\n\n同样，所谓的圣杯模式也是同样的道理。这里直接就使用`Object.create()`方法来代替寄生式继承的详细写法。\n\n```js\nfunction inherit(target, origin) {\n    function F() {};\n    F.prototype = origin.prototype;\n    target.prototype = new F();\n    target.prototype.constructor = target;\n    target.prototype.uber = origin;\n}\n```\n\n## 小结\n\n​\tECMAScript支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象：\n\n* 工厂模式，使用简单的函数传教对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。\n* 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。\n* 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。\n\n​\tJavaScript主要通过原型链实现继承。原型链的构建时通过将一个类的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过构造函数继承实例属性。\n\n​\t此外，还存在下列可供选择的继承模式：\n\n* 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质式执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。\n* 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。\n* 寄生组合式继承，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。\n\n> 我更加喜欢寄生组合式继承，也就是常说的“圣杯模式”。","desc":"Standing on Shoulders of Giants.\n\n本篇参考与《JavaScript高级程序设计》第六章：面向对象的程序设计。\n\n面向对象（Object-Oriented，OO）的语言...","title":"JavaScript 面向对象的程序设计","date":"2020-07-27T16:42:32.000Z","tags":"JavaScript","categories":"笔记","url":"javascript-object-oriented-programming","index_img":"/images/JavaScript面向对象的程序设计/logo.webp"}},"__N_SSG":true}