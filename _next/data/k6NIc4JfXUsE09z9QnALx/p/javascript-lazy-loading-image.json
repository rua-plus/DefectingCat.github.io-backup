{"pageProps":{"postData":{"id":"javascript-lazy-loading-image","content":"\n图片懒加载是一个常见的应用，它旨在不影响用户体验的情况下提示首屏的加载速度。原理很简单，在当前可视视口（Viewport）外的图片等到进入了视口内再进行加载（按需加载）。\n\n## 资源处理请求\n\n浏览器对于不同资源的下载请求有着不同的优先级。在基于 Chromium 的浏览器中，有着这样的优先级：\n\n![](../images/原生图片懒加载/2021-03-12-23-38-13.webp)\n\n在默认情况下，那些在可视视口外的图片可能有着更高的加载优先级。而可视视口外的图片提前加载是没有必要的，这就可能会造成其他关键的资源（如首屏时间、`xhr call`等）加载缓慢。\n\n> 目前的 Chromium 可能会智能一点，视口外的图片优先级没有那么高\n\n## 最基础实现\n\n这里主要使用一张小图作为占位图片（placeholder)，然后再使用 JavaScript 去加载真正的图片。\n\n这里的核心就是加载图片的`loadImg()`方法。它通过将图片的 src 属性进行替换，替换为提前设置的真正图片的地址`data-src`。实现加载真正的图片。\n\n光靠这一个方法还不行，通过`document.querySelectorAll('img[data-src]')`取得的所有 img 标签的集合为一个 NodeList。还需要使用`forEach()`方法来为每个图片执行`loadImg()`方法。\n\n后续的懒加载还需要使用到`loadImg()`方法来加载真正的图片。\n\n```js\nfunction createImg() {\n  let frag = document.createDocumentFragment();\n  let num = 28;\n  for (let i = 0; i < 9; i++) {\n    let img = document.createElement('img');\n    // placeholder 地址\n    img.src = './img/placeholder.gif';\n    // 图片真实地址\n    img.setAttribute('data-src', `./img/file_49639${num}.png`);\n    num++;\n    frag.append(img);\n  }\n  return frag;\n}\nlet images = createImg();\ndocument.body.append(images);\n\n// 选中所有懒加载的图片\nlet allImg = document.querySelectorAll('img[data-src]');\n// 接受一个 img 元素作为参数\nfunction loadImg(img) {\n  img.src = `${img.getAttribute('data-src')}`;\n  // 加载完成后移除 data-src 属性\n  img.addEventListener('load', loadHandler);\n  function loadHandler() {\n    img.removeAttribute('data-src');\n    // 执行一次后移除 load 监听器\n    img.removeEventListener('load', loadHandler);\n  }\n}\n// forEach 遍历，加载每个图片\nallImg.forEach((val) => {\n  loadImg(val);\n});\n```\n\n## 懒加载的实现\n\n懒加载的主要实现还是靠一个新兴的 API ：Intersection Observer API。\n\n早期通过检查元素`Element.getBoundingClientRect()`的 top 值与浏览器可视高度`document.documentElement.clientHeight`是否相交也是个不错的办法。但 Intersection Observer API 毕竟还是原生的 API，用起来也更加方便（~~买新不买旧~~）。\n\n在[兼容性](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7)方面，除了 IE 几乎新版浏览器都支持该 API。\n\n> 当然 IE 是不支持的。\n\nIntersection Observer API 会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时（或者 viewport），或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。\n\n通过 Intersection Observer 来监听图片与可视视口是否相交，也就是监听图片是否进入了可视区域。当图片可视时，就调用回调函数，替换 placehol 加载真正的图片。\n\nIntersection observer 支持多个 options。options 为可选配置，对于图片懒加载，默认的配置就足够了。默认监听 target 与可视视口的相交。\n\n回调函数接受两个参数：IntersectionObserverEntry 和 observe 自身。其中 IntersectionObserverEntry 就是主要用到的参数。它有多个属性：\n\n* `IntersectionObserverEntry.boundingClientRect`只读\n\n  返回包含目标元素的边界信息的 DOMRectReadOnly. 边界的计算方式与  `Element.getBoundingClientRect()`相同。\n\n* `IntersectionObserverEntry.intersectionRatio`只读\n\n  返回 intersectionRect 与 boundingClientRect 的比例值.\n\n* `IntersectionObserverEntry.intersectionRect`只读\n\n  返回一个 DOMRectReadOnly 用来描述根和目标元素的相交区域.\n\n* `IntersectionObserverEntry.isIntersecting`只读\n\n  返回一个布尔值, 如果目标元素与交叉区域观察者对象(intersection observer) 的根相交，则返回 true .如果返回 true, 则 IntersectionObserverEntry 描述了变换到交叉时的状态; 如果返回 false, 那么可以由此判断,变换是从交叉状态到非交叉状态.\n\n* `IntersectionObserverEntry.rootBounds`只读\n\n  返回一个 DOMRectReadOnly 用来描述交叉区域观察者(intersection observer)中的根.\n\n* `IntersectionObserverEntry.target`只读\n\n  与根出现相交区域改变的元素 (Element).\n\n* `IntersectionObserverEntry.time`只读\n\n  返回一个记录从 IntersectionObserver 的时间原点(time origin)到交叉被触发的时间的时间戳(DOMHighResTimeStamp).\n\n其中 isIntersecting 和 target 就是本次需要用到的属性。原理很简单，当图片与视口相交时（isIntersecting），就将图片（target）运行指定的函数，以加载真正的图片。\n\n```js\n// 创建一个 observer 对象，接受一个回调\nlet observer = new IntersectionObserver((entries, observer) => {\n  // IntersectionObserverEntry 参数\n  // console.log(entries);\n  // entries 就是 IntersectionObserverEntry 的集合。\n  entries.forEach((entry) => {\n    // 当 IntersectionObserverEntry 的 isIntersecting 为 true 时，则图片出现\n    if (entry.isIntersecting) {\n      // 使用加载函数 加载目标，entry.target 就是目标图片\n      loadImg(entry.target);\n      // 加载完成后取消监听图片\n      observer.unobserve(entry.target);\n    }\n  });\n});\n// 为所有图片监听\nallImg.forEach((val) => {\n  observer.observe(val);\n});\n```\n\n## 内容抖动\n\n内容抖动指的是在替换 placehol 到真正的图片时大小不一致导致的布局变化。\n\n由于每张图片的大小（宽高）可能都不一样，在加载了真正图片之后，布局被图片所撑开或缩小。内容抖动在浏览体验上可能影响不是非常大，但解决内容抖动也是图片懒加载的必要。\n\n解决内容抖动有很多影响的因素，选择一个合适的 placeholder 是一个重要的步骤。根据图片的尺寸来选择合适的 placeholder ：\n\n * 图片的尺寸已知\n  \n    这种情况下可以手动制作一个等比例的 placeholder 或者使用类似 [placeholder.com](https://placeholder.com/) 这样的网站来制作合适的 placeholder。\n\n * 图片的尺寸未知\n\n    在图片尺寸未知的情况下，可以考虑使用一些在线的云服务（如 CDN 的图片处理）来动态的根据图片制作 placeholder。\n\n## 解决内容抖动\n\n制作了等比例的 placeholder 还不能解决所有的问题。由于`<img>`标签的特性，在图片为加载时，该标签的尺寸是无法确定的。它会随着图片的大小变化。而正是这一特性，它和图片一样只指定一个宽或高时，会等比缩放。\n\n除了特殊需求外，图片几乎都是等比缩放。所以只需要给图片的宽和高设置一个值即可。\n\n### Aspect Ratio Boxes\n\n长宽比盒子。在一个盒子模型中，`padding-top`与`padding-bottm`属性设置为百分比时，依据的是盒子的宽度。\n\n也就是说，只要确定了盒子的宽度，就能够使用`padding`设置为百分比来画出一个等比例的盒子。\n\n例如一个 16:9 的长方形：\n\n<p class=\"codepen\" data-height=\"321\" data-theme-id=\"light\" data-default-tab=\"css,result\" data-user=\"Defectink\" data-slug-hash=\"GRNzGam\" data-preview=\"true\" style=\"height: 321px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"Aspect Ratio Boxes\">\n  <span>See the Pen <a href=\"https://codepen.io/Defectink/pen/GRNzGam\">\n  Aspect Ratio Boxes</a> by Defectink (<a href=\"https://codepen.io/Defectink\">@Defectink</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://cpwebassets.codepen.io/assets/embed/ei.js\"></script>\n\n```css\n.wrapper {\n  overflow: hidden;\n  height: 0;\n  padding-top: 56.25%;\n  background-color: red;\n  position: relative;\n}\n```\n\n上述 div 的宽度默认为 100%，而`padding-top`的值就是`9 / 16 * 100% = 56.25%`得出的值。当为指定比例的比值时，由内边距绘制出的盒子将一直保持着 16:9 的比例。\n\n这种等比例的盒子对图片内容防抖动也有一定的用处，将图片包裹在一个等于图片比例的盒子内。由于 img 标签的特性，在图片未加载时，其本身和父元素均没有高度。而 div 元素本身的宽度默认为 100%，利用这一点，就可以在图片未加载完成时，先使用长宽比盒子为图片提供一个占位符。等图片懒加载完成后再覆盖内边距。\n\n<p class=\"codepen\" data-height=\"265\" data-theme-id=\"light\" data-default-tab=\"css,result\" data-user=\"Defectink\" data-slug-hash=\"ZEBwMyL\" data-preview=\"true\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"长宽比盒子占位\">\n  <span>See the Pen <a href=\"https://codepen.io/Defectink/pen/ZEBwMyL\">\n  长宽比盒子占位</a> by Defectink (<a href=\"https://codepen.io/Defectink\">@Defectink</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://cpwebassets.codepen.io/assets/embed/ei.js\"></script>\n\n### 手动设置尺寸\n\n上述长宽比盒子解决防抖动时是需要知道图片的比例的。如果图片都是一样的比例，那么使用长宽比盒子来防抖动也是个不错的选择。\n\n但既然已经知道了图片的尺寸，那么直接给 img 标签添加对应的宽度来防止内容的抖动。将尺寸特别小的 placeholder 放大时，再配合上`filter: blur(10px)`来添加一个模糊。一个丝滑的图片懒加载就做好了。\n\n通常从后端拿到的图片数据格式可能是这样的，其中会包含图片的尺寸信息：\n\n```js\n{\n  src: './img/file_4963928.webp',\n  ph: './img/placeholder/file_4963928.webp',\n  w: 450,\n  h: 512,\n},\n```\n\n在生成图片时只需要设置长或宽其中一个尺寸即可：\n\n```js\nfunction createImg2() {\n  let frag = document.createDocumentFragment();\n  for (let i of requestImg) {\n    let img = document.createElement('img');\n    // placeholder 地址\n    img.src = `${i.ph}`;\n    // 图片真实地址\n    img.setAttribute('data-src', `${i.src}`);\n    // 根据请求的图片尺寸动态设置尺寸\n    img.style.width = `${i.w}px`;\n    // img.style.height = `${i.h}px`;\n    frag.append(img);\n  }\n  frag.append(document.createElement('hr'));\n  return frag;\n}\n```\n\n## Demo\n\n在线 [Demo](https://codesandbox.io/s/defectingcatlazy-load-image-wbiz0)\n\n## 参考\n\n* [Chrome Resource Priorities and Scheduling](https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc/edit#)\n* [浏览器里的资源请求](https://blog.windstone.cc/front-end/browser-env/browser/browser-requests.html)\n* [Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)\n* [IntersectionObserverEntry](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry)\n* [Aspect Ratio Boxes](https://css-tricks.com/aspect-ratio-boxes/)\n","desc":"图片懒加载是一个常见的应用，它旨在不影响用户体验的情况下提示首屏的加载速度。原理很简单，在当前可视视口（Viewport）外的图片等到进入了视口内再进行加载（按需加载）。\n\n资源处理请求\n\n浏览器对于...","title":"原生图片懒加载","date":"2021-03-12T21:00:00.000Z","tags":"JavaScript","categories":"实践","url":"javascript-lazy-loading-image","index_img":"/images/原生图片懒加载/logo.gif"}},"__N_SSG":true}