{"pageProps":{"postData":{"id":"todolist-exercise","content":"\n## 为什么要迫害 ToDoList\n\n摸鱼了也挺长时间，是时候该尝试写个小[案例](https://defectingcat.github.io/todolist/)安慰下自己了。\n\n![](../images/某咸鱼的ToDoList实践/2021-02-11-17-49-56.webp)\n\n## 组件划分\n\n对于 ToDoList 来说，没有多少组件化的东西。主要还是对一些基本知识的练习。所以我将其划分了一个父组件和两个子组件，他们分别是：用于输入的 Button 和用于展示数据 List。\n\n两个子组件分别对存在于父组件内保存的列表进行增删改的操作。\n\n## 整体功能\n\n目录结构：\n\n```\n$ tree -l 4 --ignore 'node_modules'\n└── src\n   ├── App.vue\n   ├── assets\n   |  ├── css\n   |  |  └── base.css\n   |  └── logo.png\n   ├── components\n   |  ├── common\n   |  |  ├── InputButton.vue\n   |  |  └── Lists.vue\n   |  └── content\n   |     └── MainTab.vue\n   └── main.js\n```\n\nMainTab 作为两个子组件 InputButton 和 Lists 的父组件：\n\n```html\n<div class=\"main-tab\">\n  <InputButton @addMsg=\"addMsg\" />\n  <Lists :lists=\"lists\" @removeItem=\"removeItem\" @editMsg=\"editMsg\" />\n</div>\n```\n\n### 添加数据\n\nInputButton 在 DOM 上添加一个 Input 与 Button 按钮，负责向父组件的 data 添加数据。在 InputButton 内：\n\n```html\n<div>\n  <input type=\"text\" v-model=\"msg\" @keyup.enter=\"emitMsg\" />\n  <button @click=\"emitMsg\">+</button>\n</div>\n```\n\n先使用`v-model`将其输入的数据双向绑定到子组件内的一个变量，然后再在按钮上绑定对应的方法将其发送给父组件。\n\n```js\nexport default {\n  data() {\n    return {\n      msg: ''\n    };\n  },\n  methods: {\n    emitMsg() {\n      this.$emit('addMsg', this.msg);\n      this.msg = '';\n    }\n  }\n};\n```\n\n父组件这边使用一个数组来保存数据：\n\n```\n[{\"id\":1,\"msg\":\"这是一个添加测试\"},{\"id\":0,\"msg\":\"这是一个测试\"}]\n```\n\nid 主要用于给`v-for`做`key`绑定用，在父组件内添加时，按照`{\"id\":1,\"msg\":\"这是一个添加测试\"}`的对象格式来添加即可，值得注意的就是 id 需要递增。\n\n### 展示数据\n\nLists 组件通过接受父组件传递的 props 来展示数据。通过一个简单的 `v-for`循环来遍历所有数据：\n\n```html\n<li v-for=\"(item, i) in lists\" :key=\"item.id\" :id=\"item.id\">\n    <span v-show=\"isEdit != item.id\">\n      {{ item.msg }}\n    </span>\n    <button @click=\"editItem(i, item.id)\">编辑</button>\n    <button @click=\"removeItem(i)\">删除</button>\n  </li>\n</ul>\n```\n\n目前的 id 用来绑定 key\n\n### 操作数据\n\n在 Lists 组件内还需要实现删除某一项和编辑某一项的功能，由于数据都保存在父组件，所有在 Lists 内所有操作都通过`$emit`将事件发射出去。\n\n```js\nmethods: {\n  removeItem(i) {\n    this.$emit('removeItem', i);\n  },\n  editItem(i, id) {\n    this.isEdit = id;\n    this.editedMsg = this.lists[i].msg;\n  },\n  editMsg(i) {\n    this.$emit('editMsg', i, this.editedMsg);\n    this.isEdit = -1;\n  }\n}\n```\n\n`removeItem(i)`是一个简单的删除当前项的方法，它通过传递 lists 的下标来确定当前项。在父组件中通过数组方法`splice()`来删除当前项：\n\n```js\n    removeItem(i) {\n      this.lists.splice(i, 1);\n    },\n```\n\n较为复杂的是编辑当前项的文字，首先需要解决的就是隐藏当前的文字，显示出一个`<input>`框。\n\n```html\n<input\n  type=\"text\"\n  v-show=\"isEdit == item.id\"\n  v-model=\"editedMsg\"\n  @keyup.enter=\"editMsg(i)\"\n  :key=\"item.id\"\n  @blur=\"editMsg(i)\"\n/>\n<span v-show=\"isEdit != item.id\">\n  {{ item.msg }}\n</span>\n```\n\n第一个想法就是通过`v-show`来判断是否显示，这里相比使用`v-if`要好点，因为这里需要来回切换。而简单的通过`true`与`false`来判断的条件是不够的，当一个添加满足了，所有的`<input>`框都会被显示出来，最终导致数据混乱。\n\n这里使用一个经典的方法，以前做 tab 切换的选项卡的时候用到过。通过给`<li>`标签添加一个 ID，并保存当前数据内的 id 来判断选中的哪一个`<li>`标签。\n\n```js\ndata() {\n  return {\n    isEdit: -1,\n    editedMsg: ''\n  };\n},\neditItem(i, id) {\nthis.isEdit = id;\nthis.editedMsg = this.lists[i].msg;\n},\n```\n\n然后通过`v-model`来绑定已经有的数据，再编辑完之后，发送一个事件到父组件，并传递修改的数据，在父组件内完成修改。现在使用`$emit`传递多个参数时可以直接在后面追加参数，在父组件中可以接受到多个参数。\n\n并且在事件发送后就表示编辑结束，需要将用于判断`v-show`的值`isEdit: -1`修改为默认状态。\n\n```js\neditMsg(i) {\n  this.$emit('editMsg', i, this.editedMsg);\n  this.isEdit = -1;\n}\n```\n\n父组件内接受到下标和数据中可以轻松实现修改：\n\n```js\neditMsg(i, message) {\n  this.lists[i].msg = message;\n}\n```\n\n`$emit`方法发送事件时可以传递多个参数，现在的版本支持多个参数分开传递，而不是对象的方式存储多个参数。在父组件中可以接受到多个参数。\n\n### Done！\n\n既然是 Todolist，那么少不了的必然是完成项目。这里用的是一个 checkbox 的`<input>`来做完成的勾选框。所以 List 组件内的结构也需要稍微变动下：\n\n```html\n<input\n  type=\"checkbox\"\n  :name=\"item.id\"\n  :id=\"item.id\"\n  :key=\"item.id\"\n  @change=\"doneItem(i)\"\n/>\n<label :for=\"item.id\">\n  <span\n    v-show=\"isEdit != item.id\"\n    :class=\"{ done: item.done }\"\n    @dblclick=\"editItem(i, item.id)\"\n    class=\"message\"\n  >\n    {{ item.msg }}\n  </span>\n</label>\n```\n\n通知父组件修改数据的方法还是同样的简单，监听`@change`属性，当 checkbox 被勾选时，发送一个下标给父组件用于定位当前的数据即可。\n\n```js\ndoneItem(i) {\n  this.$emit('doneItem', i);\n}\n```\n\n这里给 lists 数组内的对象额外增加了一个`done`属性，默认值为`false`，它现在类似于这样`{ id: this.id, msg: msg, done: false }`。\n\n在父组件中接受到下标时，定位到指定的属性中，将`done`属性修改为`true`则为项目完成。\n\n```js\ndoneItem(i) {\n  this.lists[i].done\n    ? (this.lists[i].done = false)\n    : (this.lists[i].done = true);\n}\n```\n\n自然完成了一个项目后，需要将其使用~~删除线~~进行标记。这里能够轻松的拿到 boolean 值的数据，配合`v-bind`一个 class 即可实现样式的切换。\n\n```html\n:class=\"{ done: item.done }\"\n```\n\n```css\n.done {\n  text-decoration: line-through;\n}\n```\n\n## 美化\n\n基本功能已经完成的差不多了，但是它还缺少一样灵魂，那就是 CSS。现在的样子惨目忍睹\n\n![](../images/某咸鱼的ToDoList实践/2021-02-02-11-40-13.webp)\n\n本🐟 CSS 比较差，所以在添加样式上花了不少的时间。不过期间也学习到了一些东西，所以也所了一些记录。\n\n### scoped 继承\n\n在父组件中`<style>`添加`scoped`属性后，因为子组件的根组件会被渲染到父组件内，所以随机添加的 Attribute 会被继承的添加到子组件渲染后**根**的标签上。\n\n![](../images/某咸鱼的ToDoList实践/2021-02-02-11-48-57.webp)\n\n### 基本样式\n\n样式的主要思路是：将父组件`fixed`到中央，其中两个子组件通过父组件上的`flex`定位，使用`align-items: center;`实现垂直居中。组件内的垂直居中也是使用同样的方法实现的。\n\n### 进度条\n\n已标记为完成的项目除以总项目再乘以 100% 就是完成进度了，既然现在可以轻松绑定到 style，那么根据完成的进度就可以轻松绑定其宽度`:style=\"{ width: process }\"`。配合上 500ms 的 transition，一个简易的进度条就做好了🎈\n\n首先是使用一个 computed 来计算完成的百分比：\n\n```js\ncomputed: {\n  process() {\n    let doneItem = [];\n    let result = 0;\n    let len = this.lists.length;\n    for (let i of this.lists) {\n      if (i.done) {\n        doneItem.push(i);\n      }\n    }\n    result = (doneItem.length / len) * 100;\n    if (Math.floor(result)) {\n      return `${Math.floor(result)}%`;\n    } else {\n      return 0;\n    }\n  }\n}\n```\n\n然后就是创建一个用于显示的标签：\n\n```html\n<div class=\"processed\" :style=\"{ width: process }\">\n```\n\n## 动画\n\nVue 提供了 transition 的封装组件，可以为我们的元素过渡添加优美的动画。\n\n![](../images/某咸鱼的ToDoList实践/2021-02-02-14-52-48.webp)\n\n在本次的案例中，使用`<transition-group>`可以为列表添加一个过渡。\n\n```html\n<transition-group name=\"list\" tag=\"ul\">\n  <li>...</li>\n<transition>\n```\n\n`enter`和`leave-to`分别是进入和离开时的过渡：\n\n```css\n.list-enter {\n  opacity: 0;\n  transform: translateY(-30px);\n}\n.list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n```\n\n我们可以只在进入或离开时添加过渡动画:\n\n```css\n.list-enter-active,\n.list-leave-active {\n  transition: all 500ms ease;\n}\n```\n\n但是这样还不够，这时只是被添加的那一个元素有了过渡动画，而其他元素都是“闪现”到其他位置的。Vue 使用了一个叫 FLIP 简单的动画队列使用 `transforms`将元素从之前的位置平滑过渡新的位置。\n\n这时不需要单独的设置`.list-enter-active, .list-leave-active`的变换效果了，可以将`li`添加一个` transition: all 500ms ease;`所有变换的效果。\n\n并且，在删除元素时，需要在`.list-leave-active`上添加`position: absolute`才能触发剩下元素的`v-move`属性。\n\n```css\n.list-leave-active {\n  /* 脱离文档才能触发v-move */\n  position: absolute;\n}\n```\n\n这样在添加新数据时看上去就不再那么突兀了。","desc":"为什么要迫害 ToDoList\n\n摸鱼了也挺长时间，是时候该尝试写个小案例安慰下自己了。\n\n\n\n组件划分\n\n对于 ToDoList 来说，没有多少组件化的东西。主要还是对一些基本知识的练习。所以我将其...","title":"某咸鱼的 ToDoList 实践🐟","date":"2021-02-11T17:47:25.000Z","tags":["JavaScript","Vue"],"categories":"实践","url":"todolist-exercise","index_img":"/images/某咸鱼的ToDoList实践/logo.webp"}},"__N_SSG":true}