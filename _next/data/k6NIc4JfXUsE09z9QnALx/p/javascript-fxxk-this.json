{"pageProps":{"postData":{"id":"javascript-fxxk-this","content":"\n## this 全面解析\n\nthis 和动态作用域有些许类似，他们都是在执行时决定的。this 是在调用时被绑定的，完全取决于函数的调用位置。\n\n### 确定调用位置\n\n当一个函数被调用是，会创建一个活动记录（执行期上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个记录里的一个属性。\n\n调用位置就是函数在代码中被调用的位置，而不是声明的位置。可以类似于这样来这个记录并分析出函数的真正调用位置。\n\n```ts\nfunction foo() {\n  // 当前调用栈：foo\n\n  console.log('foo');\n  bar();\n}\nfunction bar() {\n  // 当前调用栈：foo --> bar\n\n  console.log('bar');\n  baz();\n}\nfunction baz() {\n  // 当前调用栈：foo --> bar --> baz\n\n  console.log('baz');\n}\nfoo();\n```\n\n### 绑定规则\n\nthis 是在运行时动态绑定的，所以在不同的情况下，this 可能会发生各种意料之外的情况。\n\n#### 默认绑定\n\n当函数在全局环境下独立调用时，this 会指向为全局对象。\n\n```ts\nvar a = 123;\nfunction foo() {\n  console.log(this.a); // 123\n}\n```\n\n而当函数处理严格模式下，则不能将全局对象用于默认绑定，因此 this 会绑定到`undefined`\n\n```ts\nvar a = 123;\nfunction foo() {\n  \"use strict\"\n  console.log(this.a); // TypeError: this is undefined\n}\n```\n\n还有一个微妙的细节，虽然 this 的绑定完全取决于调用的位置，但是只有`foo()`函数本身处于非严格模式才能绑定到全局对象。如果只是函数执行时所在严格模式下，而本身是非严格模式，则不影响默认绑定规则。\n\n```ts\nvar a = 123;\n\nfunction foo() {\n  console.log(this.a);\n}\n\n(() => {\n  'use strict';\n  foo();\n})();\n```\n\n> 通常来说不推荐在代码中混用严格模式与非严格模式。\n\n#### 隐式绑定\n\n另外一种规则是考虑调用位置是否有上下文对象，或者说某个对象是否包含这个函数。\n\n```ts\nfunction foo(this: typeof obj) {\n  console.log(this.name);\n}\nconst obj = {\n  name: 'xfy',\n  foo: foo\n};\nobj.foo() // xfy\n```\n\n这种方法可以理解为将`foo()`的函数体赋值给了对象 obj 的一个属性，而执行时是从 obj 作为上下文对象来执行的。所以 this 隐式的绑定到了 obj 对象。\n\n对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。\n\n```ts\nfunction foo(this: typeof obj) {\n  console.log(this.name);\n}\nconst obj = {\n  name: 'xfy',\n  foo: foo,\n};\nobj.foo(); // xfy\n\nconst alotherObj = {\n  name: 'dfy',\n  obj: obj,\n};\nalotherObj.obj.foo(); // xfy\n```\n\n**隐式丢失**\n\n既然会隐式的绑定，那也就会出现隐式的丢失问题。\n\n```js\nfunction foo() {\n  console.log(this.name);\n}\n\nconst obj = {\n  name: 'xfy',\n  age: 18,\n  foo,\n};\n\nconst bar = obj.foo; // 函数别名\nbar();\n```\n\n虽然 bar 是`obj.foo`的一个引用，但是它引用的是函数体本身。可以理解为将函数体传递给了 bar 这个变量，这是调用`bar()`是一个不带任何修饰的函数调用，因此使用了默认绑定。\n\n另一种常见且出乎意料的情况就是在传递回调函数时：\n\n```js\n  function foo() {\n    console.log(this.name);\n  }\n\n  function doFoo(fn) {\n    fn();\n  }\n\n  const obj = {\n    name: 'xfy',\n    age: 18,\n    foo,\n  };\n\n  doFoo(obj.foo);\n```\n\n参数传递其实就是一种隐式赋值，因此我们传入函数是也会被隐式赋值。只要函数体被传递后，且调用时脱离了原有的对象，就会导致 this 的隐式丢失。\n\n包括`setTimeout()`方法丢失 this 也是同理。\n\n#### 显式绑定\n\n因为原型的特性，JavaScript 中函数也自己的属性。大多数宿主环境都会提供`call()`与`apply()`来给我们显式的绑定 this。\n\n```js\n  function foo() {\n    console.log(this.name);\n  }\n  const obj = {\n    name: 'xfy',\n    age: 18,\n    foo,\n  };\n  foo.call(obj);\n```\n\n> call 与 apply 只是传参不同。\n\n使用显式的绑定可以很好的解决传递参数时隐式丢失 this 的问题\n\n```js\n  function foo() {\n    console.log(this.name);\n  }\n  const obj = {\n    name: 'xfy',\n    age: 18,\n    foo,\n  };\n  function bar() {\n    foo.call(obj);\n  }\n  setTimeout(bar, 1000);\n  // 同理\n  // setTimeout(() => {\n  //   obj.foo();\n  // }, 1000);\n```\n\n这里在`bar()`的内部直接手动显式的把`foo()`绑定到了 obj，无论之后怎么调用，在何处调用。都会手动的将 obj 绑定在`foo()`上。这种绑定称之为**硬绑定**。\n\n不过这种绑定是特意的例子，这里手动为`foo()`绑定到了 obj。在多数情况下，我们可能需要更灵活一点。\n\n在 [JavaScript 装饰器模式🎊 - 🍭Defectink (xfy.plus)](https://xfy.plus/defect/javascript-decorator.html) 中介绍了这种工作模式。通过一个包装器配合显式绑定就能解决大部分情况下的问题。\n\n```js\n  function foo(msg) {\n    console.log(this.name);\n    console.log(msg);\n  }\n  function wrapper(fn, obj) {\n    return (...rest) => {\n      fn.apply(obj, rest);\n    };\n  }\n  const obj = {\n    name: 'xfy',\n    age: 18,\n  };\n  const bar = wrapper(foo, obj);\n  bar('嘤嘤嘤');\n```\n\n但包装器不仅仅只是用来解决 this 丢失的问题，但对 this 绑定的问题 ES5 提供了内置的方法`Function.prototype.bind`。\n\n```js\n  function foo() {\n    console.log(this.name);\n  }\n  const obj = {\n    name: 'xfy',\n    age: 18,\n  };\n  const bar = foo.bind(obj);\n  bar();\n```\n\n#### new 绑定\n\n在传统面向类的语言中，“构造函数”是类中的一些特殊的方法，使用类时会调用类中的构造函数。通常类似于这样：\n\n```js\nmyObj = new MyClass()\n```\n\n在 JavaScript 中，所有函数都可以被 new 操作符所调用。这种调用称为构造函数调用，实质上并不存在所谓的“构造函函数”，只有对于函数的“构造调用”。\n\n使用 new 来发生构造函数调用时，会执行：\n\n1. 创建（构造）一个新对象。\n2. 对新对象执行`[[Prototype]]`连接。\n3. 对新对象绑定到函数调用的 this。\n4. 如果函数没有返回其他对象，那么在 new 调用后自动返回这个新对象。\n\n```js\nfunction Foo(name) {\n  this.name = name;\n}\nconst bar = new Foo('xfy');\nconsole.log(bar.name);\n```\n\n使用 new 操作符来调用`foo()`时，会构造一个新对象并把它绑定到`foo()`中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。\n\n> ES6 的 class 只是一个语法糖，但是它也解决了一些问题。\n\n### 优先级\n\n上述描述的四条规则中，如果某处位置可以应用多条规则时，就要考虑到其优先级的问题。\n\n毫无疑问，默认绑定肯定是优先级最低的绑定。所以先来考虑隐式绑定与显式绑定之间的优先级，用一个简单的方法就能测试出：\n\n```js\nfunction foo() {\n  console.log(this.age);\n}\n\nconst xfy = {\n  name: 'xfy',\n  age: 18,\n  foo,\n};\nconst dfy = {\n  name: 'dfy',\n  age: 81,\n  foo,\n};\n\nxfy.foo();  // 18\ndfy.foo();\t// 81\n\nxfy.foo.call(dfy);\t// 81\ndfy.foo.call(xfy);\t// 18\n```\n\n很明显，显式绑定的优先级更高，也就是说在判断时应当先考虑是否存在显式绑定。\n\n那么 new 绑定与隐式绑定呢？\n\n```js\nfunction foo(msg) {\n  this.a = msg;\n}\n\nconst xfy = {\n  name: 'xfy',\n  foo,\n};\nxfy.foo('test');\nconsole.log(xfy);\n\nconst obj = new xfy.foo('this is obj');\nconsole.log(obj);\n```\n\n可以看到这里对对象 xfy 中隐式绑定的函数进行了 new 操作，而最后的 this 被绑定到了新对象 obj 上，并没有修改 xfy 本身的值。所以 new 绑定的优先级比隐式绑定更高。\n\n那 new 绑定与显式绑定呢？由于`call/apply`无法与 new 一起使用，所以无法通过`new xfy.foo.call(obj)`来测试优先级，但是我们可以通过硬绑定`bind()`来测试。\n\n```js\nfunction foo(msg) {\n  this.a = msg;\n}\n\nconst xfy = {\n  name: 'xfy',\n  foo,\n};\n\nlet obj = {};\n\nconst bar = xfy.foo.bind(obj);\nbar('obj');\nconsole.log(obj);\n\n// bar was bind to obj\nconst baz = new bar('this is baz');\nconsole.log(obj);\nconsole.log(baz);\n```\n\n可以看到，在硬绑定之后，使用 new 操作对象 obj 的值并没有被改变，反而对 new 的新对象进行了修改。\n\n但这真的说明 new 绑定比硬绑定优先级更高吗？实则不然，上述结果是因为 ES5 中内置的`Function.prototype.bind()`方法比较复杂，他会对 new 绑定做判断，如果是的话就会使用新创建的 this 替换硬绑定的 this。\n\n这是来自 [MDN]([Function.prototype.bind() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#polyfill))的 polyfill bind 的方法，\n\n```js\n//  Yes, it does work with `new (funcA.bind(thisArg, args))`\nif (!Function.prototype.bind)\n  (function () {\n    var ArrayPrototypeSlice = Array.prototype.slice;\n    Function.prototype.bind = function (otherThis) {\n      if (typeof this !== 'function') {\n        // closest thing possible to the ECMAScript 5\n        // internal IsCallable function\n        throw new TypeError(\n          'Function.prototype.bind - what is trying to be bound is not callable'\n        );\n      }\n\n      var baseArgs = ArrayPrototypeSlice.call(arguments, 1),\n        baseArgsLength = baseArgs.length,\n        fToBind = this,\n        fNOP = function () {},\n        fBound = function () {\n          baseArgs.length = baseArgsLength; // reset to default base arguments\n          baseArgs.push.apply(baseArgs, arguments);\n          return fToBind.apply(\n            fNOP.prototype.isPrototypeOf(this) ? this : otherThis,\n            baseArgs\n          );\n        };\n\n      if (this.prototype) {\n        // Function.prototype doesn't have a prototype property\n        fNOP.prototype = this.prototype;\n      }\n      fBound.prototype = new fNOP();\n\n      return fBound;\n    };\n  })();\n```\n\n在这几段中：\n\n```js\nfNOP.prototype.isPrototypeOf(this) ? this : otherThis,\n// 以及\nif (this.prototype) {\n  // Function.prototype doesn't have a prototype property\n  fNOP.prototype = this.prototype;\n}\nfBound.prototype = new fNOP();\n```\n\n该 polyfill 检测了是否是使用 new 绑定，并修改 this 为 new 绑定。\n\n#### 判断 this\n\n根据上述优先级，可以得出一些判断 this 的结论（优先级从高到低）：\n\n1. 函数是否在 new 中调用（new 绑定）？\n\n   如果是的话， this 绑定的是新创建的对象。`const bar = new Foo()`\n\n2. 函数是否通过`call/apply`或者硬绑定调用（显式绑定）？\n\n   如果是的话，this 绑定的是指定的对象。`const bar = foo.call(baz)`\n\n3. 函数是否在某个上下文对象中调用（隐式绑定）？\n\n   如果是的话，this 绑定在那个上下文对象上。`const bar = obj.foo()`\n\n4. 上述都不满足，那么就会使用默认绑定。\n\n### 绑定例外\n\n凡事都有例外，this 绑定也是同样。在某些情况下看上去可能是绑定某个规则，但实际上应用的可能是默认规则。\n\n#### 被忽略的 this\n\n把 null 或者 undefined 作为 this 的绑定对象传入`call/apply`与 bind 方法时，这些值会被忽略，从而应用默认绑定规则。\n\n也就是说`call/apply`传入 null 或者 undefined 时与之间执行函数本身没有区别。\n\n```js\nfunction foo() {\n  console.log(this.name);\n}\nfoo.call(null);\n```\n\n这样使用`call/apply`的作用是利用他们的一些特性来解决一些小问题。\n\n例如：展开数组\n\n```js\nfunction bar(a, b) {\n  console.log(a, b);\n}\nbar.apply(null, [1, 2]);\n```\n\n当然，这在 ES6 中可以使用展开运算符来传递参数：\n\n```js\nbar(...[1,2])\n```\n\n又或是利用 bind 实现柯里化\n\n```js\nfunction bar(a, b) {\n  console.log(a, b);\n}\n\nconst baz = bar.bind(null, 1);\nbaz(2);\n```\n\n这里都是利用忽略 this 产生的一些副作用，但在某些情况下可能不安全，例如函数可能真的使用到了 this ，这在非严格模式下可能会修改全局对象。\n\n如果真的需要使用这种方法，可以创建一个 DMZ 对象来代替 null。\n\n```js\nconst ¤ = Object.create(null);\nfoo.call(¤, arg)\n```\n\n#### 间接引用\n\n另外需要注意的是，在某些情况下我们可能会无意的创建一个函数的间接引用。间接引用最容易在赋值期间发生：\n\n```js\nfunction foo() {\n  console.log(this.name);\n}\nconst o = {\n  foo,\n};\nconst p = {};\n(p.foo = o.foo)();\n```\n\n赋值表达式`p.foo = o.foo`返回的是目标函数的引用，所以在这里调用实际上是在全局环境下直接调用`foo()`。根据之前的规则，这里会应用默认绑定。","desc":"this 全面解析\n\nthis 和动态作用域有些许类似，他们都是在执行时决定的。this 是在调用时被绑定的，完全取决于函数的调用位置。\n\n确定调用位置\n\n当一个函数被调用是，会创建一个活动记录（执行...","title":"JavaScript-this全面解析","date":"2021-07-12T11:38:03.000Z","tags":"JavaScript","categories":"笔记","url":"javascript-fxxk-this"}},"__N_SSG":true}