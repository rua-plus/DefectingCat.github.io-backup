{"pageProps":{"postData":{"id":"typescript-pieces","content":"\n## 类型\n\n```ts\n// 基础类型 null, undefined, symbol, boolean, void\nconst count: number = 123;\nconst teacherName: string = 'Dell';\n\n// 对象类型\n\nclass Person {}\n\nconst teacher: {\n  name: string;\n  age: number;\n} = {\n  name: 'Dell',\n  age: 18\n};\n\nconst numbers: number[] = [1, 2, 3];\n\nconst dell: Person = new Person();\n\nconst getTotal: () => number = () => {\n  return 123;\n};\n\n```\n\n### 基本类型\n\n当复制和变量定义不在同一行时，ts 就无法推断类型。\n\n```js\nstring, number\n```\n\n```js\nnull, undefined, symbol, boolean, void\n```\n\n### 引用值\n\n数组，对象，类，函数\n\n## 函数返回类型\n\n函数也可以指定返回值的静态类型\n\n```ts\nfunction test(data: { x: number }): object {\n  console.log(data.x);\n  return data;\n}\n\ntest({ x: 123 });\n\n```\n\n如果没有返回值，则使用`void`指定\n\n```ts\nfunction test(data: { x: number }): void {\n  console.log(data.x);\n}\n\ntest({ x: 123 });\n\n```\n\n### never\n\n指定`never`返回值表示该函数永远不会执行完\n\n```ts\nfunction test(): never {\n  while (true) {}\n}\n\n```\n\n### 解构参数类型注解\n\n```ts\nfunction add({\n  firstNumber,\n  secondNumber,\n}: {\n  firstNumber: number;\n  secondNumber: number;\n}): number {\n  return firstNumber + secondNumber;\n}\nadd({ firstNumber: 1, secondNumber: 2 });\n\n```\n\n### 匿名函数的类型注解\n\n```ts\nconst fn = (data: { x: number }): number => {\n  return data.x;\n};\nconst fnc: (str: string) => string = (str) => {\n  return str;\n};\n\n```\n\n## 数组和元组\n\n### 数组的类型注解\n\n```ts\nconst arr: (number | string)[] = [1, '2', 3];\nconst arr: (number | string)[] = [1, '2', 3];\nconst objArr: object[] = [{}, {}];\nconst obj1Arr: { name: string }[] = [{ name: 'xfy' }];\nconst obj2Arr: ({ name: string } | number)[] = [{ name: 'xfy' }, 123];\n\n```\n\n### 类型别名\n\n类型别名和`interface`类似\n\n```ts\ntype User = {\n  name: string;\n  age: number;\n};\nconst arr1: User[] = [{ name: 'xfy', age: 18 }];\n\ninterface User1 {\n  name: string;\n  age: number;\n}\nconst arr2: User1[] = [{ name: 'xfy', age: 18 }];\n\n```\n\n### 元组\n\ntuple，数据解构和数组类似，但可以指定每一项的数据类型。\n\n```ts\nconst tuple: [string, number] = ['xfy', 18];\nconst csv1: [string, number][] = [];\n```\n\n## interface\n\ninterface 用于定义一个新的类型集合\n\n```ts\ninterface Person3 {\n  name: string;\n}\nconst sayName = (person: Person3): void => {\n  console.log(person.name);\n};\nsayName({ name: 'xfy' });\n\n```\n\n### 类型别名和`interface`区别\n\n类型别名可以直接指定单个类型，而接口必须为一个对象\n\n```ts\ninterface Person1 {\n  name: string;\n}\ntype Person2 = string;\n\n```\n\n能用接口的尽量使用接口来定义。\n\n### 可选类型\n\n一种类似于可选链的语法，通过 interface 注解可选的数据类型\n\n```ts\ninterface Person4 {\n  name: string;\n  age?: number;\n}\nconst fn1 = (person: Person4): void => {\n  console.log(person.name);\n};\nfn1({ name: 'xfy', age: 18 });\n```\n\n### 只读\n\n```ts\ninterface Person5 {\n  readonly name: string;\n  age?: number;\n}\nconst fn2 = (person: Person5): void => {\n  console.log(person.name);\n  person.name = 'test';  // Cannot assign to 'name' because it is a read-only property.\n};\nfn2({ name: 'xfy', age: 18 });\n\n```\n\n### 强类型检查\n\n当 interface 注解类型时，通过直接传递对象字面量就会进行强类型检查。ts 会检查对象字面量内的每个属性，多余的属性将无法通过检查。\n\n而通过使用一个对象表达式将一个变量进行传递时，检查不会那么严格。\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n}\nconst fn3 = (person: Person6): void => {\n  console.log(person.name);\n  // person.name = 'test';\n};\nfn3({ name: 'xfy', sex: 'female' });  //  'sex' does not exist in type 'Person6'.\nconst person1 = {\n  name: 'xfy',\n  sex: 'female',\n};\nfn3(person1);\n```\n\n### 其他属性注解\n\n通过 interface 直接注解的类型无法传递对象字面量传递未注解的属性，可以使用定义其他变量的类型注解\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n}\nconst fn3 = (person: Person6): void => {\n  console.log(person.name);\n  // person.name = 'test';\n};\nfn3({ name: 'xfy', sex: 'female' });\n```\n\n### 注解方法\n\n除了注解指定的属性类型，还可以注解方法，并注解函数的返回值类型\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n  say(): string;\n}\nconst fn3 = (person: Person6): void => {\n  console.log(person.name);\n  // person.name = 'test';\n};\nfn3({\n  name: 'xfy',\n  sex: 'female',\n  say() {\n    return 'yyy';\n  },\n});\n```\n\n### 类\n\n使用 implements 语法\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n  say(): string;\n}\nclass User2 implements Person6 {\n  name: 'test';\n  say() {\n    return 'yyy';\n  }\n}\n\n```\n\n### 接口继承\n\n接口继承的语法与类继承类似\n\n```ts\ninterface Person7 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n  say(): string;\n}\ninterface Teach extends Person7 {\n  teach(): void;\n}\nconst test3 = (person: Teach): void => {};\ntest3({\n  name: 'xfy',\n  say() {\n    return 'yyy';\n  },\n  teach() {},\n});\n\n```\n\n## 类\n\nTypeScript 中为类定义了多个声明关键字。帮助类声明公共与私有属性。\n\n### public\n\n默认情况下直接声明的属性是通过 public 声明的，即在外部也能正常访问该属性。\n\n```ts\nclass Person {\n  name = 'xfy';\n  sayName() {\n    return this.name;\n  }\n}\n\nlet xfy = new Person();\nconsole.log(xfy.sayName());\nconsole.log(xfy.name);\n```\n\n### private\n\nprivate 与 public 相对立。通过 private 声明的属性只能在当前类的内部被访问到，即使是继承的子类也无法直接访问。\n\n```ts\nclass Person {\n  private name = 'xfy';\n  sayName() {\n    return this.name;\n  }\n}\n\nlet xfy = new Person();\nconsole.log(xfy.sayName());\nconsole.log(xfy.name); // Property 'name' is private and only accessible within class 'Person'.\n\nclass Teacher extends Person {\n  say() {\n    return this.name;  // Property 'name' is private and only accessible within class 'Person'.\n  }\n}\n\n```\n\n### protected\n\n与 private 类型，protected 的属性也无法在外部被访问。但是可以在继承的子类中被访问到。\n\n```ts\nclass Person {\n  private name = 'xfy';\n  sayName() {\n    return this.name;\n  }\n}\n\nlet xfy = new Person();\nconsole.log(xfy.sayName());\nconsole.log(xfy.name); // Property 'name' is private and only accessible within class 'Person'.\n\nclass Teacher extends Person {\n  say() {\n    return this.name;  // ok\n  }\n}\n\n```\n\n### constructor\n\n与 JavaScript 的 constructor 不同的是，在 TypeScript 中 constrcutor 需要先在类中定义对应的 public 属性。\n\n```ts\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nlet xfy = new Person('xfy');\nconsole.log(xfy.name);\n```\n\n为了方便起见，TypeScript 也有简写 constructor 参数的方法。并且不需要再在内部添加`this.name`了。编译器会帮我们自动生成。\n\n```ts\nclass Person {\n  // name: string;\n  constructor(public name: string) {\n    // this.name = name;\n  }\n}\nlet xfy = new Person('xfy');\nconsole.log(xfy.name);\n\n```\n\nconstructor 继承时的用法与传统 JavaScript 类似。\n\n```ts\nclass Person {\n  // name: string;\n  constructor(public name: string) {\n    // this.name = name;\n  }\n}\nlet xfy = new Person('xfy');\nconsole.log(xfy.name);\n\nclass Teacher extends Person {\n  constructor(name: string, public age: number) {\n    super(name);\n  }\n}\nlet t = new Teacher('xfy', 18);\n\n```\n\n> 即使父类没有 constructor，子类继承时也需要调用`super()`\n\n### 抽象类\n\n在定义多个有相似方法的类时，可以定义一个抽象类来为同样的方法注解类型。抽象类中也可以包含实际的内容。\n\n```ts\nabstract class Geo {\n  width: number;\n  abstract getAare(): number;\n}\n\nclass Circle extends Geo {\n  // width = '123';\n  width = 123;\n  getAare() {\n    return 123;\n  }\n}\nclass Square extends Geo {\n  getAare() {\n    return 123;\n  }\n}\nclass Triangle extends Geo {\n  getAare() {\n    return 123;\n  }\n}\n\n```\n\n## 单例模式\n\n单例模式（Singleton Pattern）是多数编程软件中常用的设计模式。通过 TypeScript 就可以为 JavaScript 创建一个单例模式的类。\n\n这里通过 private 将 constructor 隐藏在类的内部。在类体上暴露一个方法`getInstance()`，通过这个方法来获取唯一的实例。同时在类体上还定义一个 private 属性 instance，它的类型注解就是该类。每次调用`getInstance()`方法时，通过检查 instance 是否有值，没有就创建一个新的实例，并缓存在 instance 内。后续直接返回 instance。这样就能够保证后续创建的实例都是同一个实例。\n\n```ts\nclass Demo {\n  private static instance: Demo;\n  private constructor(public name: string) {}\n  static getInstance(name: string) {\n    if (!Demo.instance) {\n      Demo.instance = new Demo(name);\n    }\n    return Demo.instance;\n  }\n}\nlet t1 = Demo.getInstance('xfy');\nlet t2 = Demo.getInstance('dfy');\nconsole.log(t1.name);\nconsole.log(t2.name);\nconsole.log(t1 === t2);\n\n```\n\n## .d.ts\n\n传统的 js 在被引入到 ts 中无法正确的被推断出类型。需要使用`.d.ts`已经注解好类型的文件来转译。\n\n通常在 @types 里`https://www.npmjs.com/package/@types`\n\n### 定义全局\n\n```ts\n$(function () {\n    $('body').html('<h1>Hi, there</h1>')\n})\n```\n\n```ts\n// 全局变量\ndeclare var $: (param: () => void)  => void;\n```\n\n```ts\ninterface JqueryInstance {\n    html: (content: string) => {}\n}\n// 函数重载\ndeclare function $(param: () => void): void;\ndeclare function $(patam: string): JqueryInstance;\n```\n\n## 函数重载\n\n使用 interface 的语法，实现函数重载\n\n```ts\ninterface JQuery {\n    (param: () => void): void;\n    (patam: string): JqueryInstance;\n}\ndeclare var $: JQuery;\n```\n\n## tsconfig\n\n使用`tsc --init`初始化一个项目时，会自动生成一个带有注释的`tsconfig.json`配置文件。这个文件就是对 TypeScript 编译的一些配置文件。\n\n一个默认的配置文件可能是这样的：\n\n```json\n{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig.json to read more about this file */\n\n    /* Basic Options */\n    // \"incremental\": true,                         /* Enable incremental compilation */\n    \"target\": \"ESNEXT\",                                /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */\n    \"module\": \"commonjs\",                           /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */\n    // \"lib\": [],                                   /* Specify library files to be included in the compilation. */\n    // \"allowJs\": true,                             /* Allow javascript files to be compiled. */\n    // \"checkJs\": true,                             /* Report errors in .js files. */\n    // \"jsx\": \"preserve\",                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */\n    // \"declaration\": true,                         /* Generates corresponding '.d.ts' file. */\n    // \"declarationMap\": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */\n    // \"sourceMap\": true,                           /* Generates corresponding '.map' file. */\n    // \"outFile\": \"./\",                             /* Concatenate and emit output to single file. */\n    // \"outDir\": \"./\",                              /* Redirect output structure to the directory. */\n    // \"rootDir\": \"./\",                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */\n    // \"composite\": true,                           /* Enable project compilation */\n    // \"tsBuildInfoFile\": \"./\",                     /* Specify file to store incremental compilation information */\n    // \"removeComments\": true,                      /* Do not emit comments to output. */\n    // \"noEmit\": true,                              /* Do not emit outputs. */\n    // \"importHelpers\": true,                       /* Import emit helpers from 'tslib'. */\n    // \"downlevelIteration\": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */\n    // \"isolatedModules\": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */\n\n    /* Strict Type-Checking Options */\n    \"strict\": true,                                 /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                    /* Enable strict null checks. */\n    // \"strictFunctionTypes\": true,                 /* Enable strict checking of function types. */\n    // \"strictBindCallApply\": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */\n    // \"strictPropertyInitialization\": true,        /* Enable strict checking of property initialization in classes. */\n    // \"noImplicitThis\": true,                      /* Raise error on 'this' expressions with an implied 'any' type. */\n    // \"alwaysStrict\": true,                        /* Parse in strict mode and emit \"use strict\" for each source file. */\n\n    /* Additional Checks */\n    // \"noUnusedLocals\": true,                      /* Report errors on unused locals. */\n    // \"noUnusedParameters\": true,                  /* Report errors on unused parameters. */\n    // \"noImplicitReturns\": true,                   /* Report error when not all code paths in function return a value. */\n    // \"noFallthroughCasesInSwitch\": true,          /* Report errors for fallthrough cases in switch statement. */\n    // \"noUncheckedIndexedAccess\": true,            /* Include 'undefined' in index signature results */\n    // \"noPropertyAccessFromIndexSignature\": true,  /* Require undeclared properties from index signatures to use element accesses. */\n\n    /* Module Resolution Options */\n    // \"moduleResolution\": \"node\",                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\n    // \"baseUrl\": \"./\",                             /* Base directory to resolve non-absolute module names. */\n    // \"paths\": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */\n    // \"rootDirs\": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeRoots\": [],                             /* List of folders to include type definitions from. */\n    // \"types\": [],                                 /* Type declaration files to be included in compilation. */\n    // \"allowSyntheticDefaultImports\": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\n    \"esModuleInterop\": true,                        /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */\n    // \"preserveSymlinks\": true,                    /* Do not resolve the real path of symlinks. */\n    // \"allowUmdGlobalAccess\": true,                /* Allow accessing UMD globals from modules. */\n\n    /* Source Map Options */\n    // \"sourceRoot\": \"\",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */\n    // \"mapRoot\": \"\",                               /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                     /* Emit a single file with source maps instead of having a separate file. */\n    // \"inlineSources\": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */\n\n    /* Experimental Options */\n    // \"experimentalDecorators\": true,              /* Enables experimental support for ES7 decorators. */\n    // \"emitDecoratorMetadata\": true,               /* Enables experimental support for emitting type metadata for decorators. */\n\n    /* Advanced Options */\n    \"skipLibCheck\": true,                           /* Skip type checking of declaration files. */\n    \"forceConsistentCasingInFileNames\": true        /* Disallow inconsistently-cased references to the same file. */\n  }\n}\n\n```\n\n仔细看的话，配置文件内主要包含一个大的字段`\"compilerOptions\"`，这是针对编译时的配置。对文件的配置还有`include`和`exclude`：\n\n```json\n{\n  \"exclude\": [\"./src/config.ts\"],\n  \"compilerOptions\": {\n\t// ...\n  }\n}\n\n```\n\n## 联合类型与类型保护\n\n当定义了多个 interface 需要同时使用时，可以使用`|`运算符来同时使用。但是这样也会遇到一个小问题，同时使用两个 interface 时，语法提示只会提示二者共有的类型注解。\n\n因为不能保证传入的参数一定会拥有独有的属性\n\n```ts\ninterface Bird {\n  fly: boolean;\n  sing: () => {};\n}\ninterface Dog {\n  fly: boolean;\n  bark: () => {};\n}\n\nfunction trainAnimal(animal: Bird | Dog) {\n  console.log(animal);\n}\n```\n\n![image-20210329172943170](../images/TypeScript%E4%B8%B4%E7%A2%8E%E7%AC%94%E8%AE%B0/image-20210329172943170.png)\n\n### 类型保护\n\n类型保护有多个方法，作用就是在特定情况下访问独有的属性。\n\n#### 类型断言\n\n断言的目的就是在当前情况下，我非常清楚指定传进来的参数有指定的参数。\n\n假设在当前例子里，参数中的`fly`属性只要为`true`时，就一定能确定是`Bird`接口的类型。那么就可以断言为：\n\n```ts\ninterface Bird {\n  fly: boolean;\n  sing: () => {};\n}\ninterface Dog {\n  fly: boolean;\n  bark: () => {};\n}\n\nfunction trainAnimal(animal: Bird | Dog) {\n  if (animal.fly) {\n    (animal as Bird).sing();\n  }\n}\n```\n\n#### `in`语法\n\n可以直接判断属性是否存在于当前实例中，TypeScript 会直接推断出对应的接口。\n\n```ts\nfunction trainAnimalSecond(animal: Bird | Dog) {\n  if (\"sing\" in animal) {\n    animal.sing();\n  }\n}\n```\n\n#### `typeof`语法\n\n和使用`in`语法类型，`typeof`语法也能让 TypeScript 做出正确的类型推断。\n\n```ts\nfunction addSomething(firstNum: string | number, secondNum: string | number) {\n  if (typeof firstNum === \"string\" || typeof secondNum === \"string\") {\n    return `${firstNum}${secondNum}`;\n  }\n  return firstNum + secondNum;\n}\n```\n\n## 枚举类型\n\n```ts\nenum Status {\n  ONLINE,\n  OFFLINE,\n  DELETED,\n}\n\nfunction getDetail(status: Status) {\n  switch (status) {\n    case Status.ONLINE:\n      console.log(\"online!\");\n      break;\n    case Status.OFFLINE:\n      console.log(\"offline!\");\n      break;\n    case Status.DELETED:\n      console.log(\"deleted!\");\n      break;\n  }\n}\n\ngetDetail(0);\n```\n\n## 函数泛型\n\n泛指的类型（generic）。通俗的说，就是不专门注解函数的参数为指定的某一个类型，函数可以接受多个类型，但参数的类型必须统一。\n\n```ts\nfunction join<T>(first: T, second: T): string {\n  return `${first}${second}`;\n}\n\njoin<string>(\"1\", \"2\");\n```\n\n也可以为指定数组内的属性指定泛型\n\n```ts\n// function map<T>(params: Array<T>) {\n//   return params;\n// }\nfunction map<T>(params: T[]) {\n  return params;\n}\nmap<number>([1, 2, 3]);\n```\n\n泛型还支持多个类型\n\n```ts\nfunction join<T, Y>(first: T, second: Y): string {\n  return `${first}${second}`;\n}\n\njoin<string, number>(\"1\", 2);\n```\n\n函数的返回类型也可以使用泛型。\n\n### 类中的泛型\n\n类也是同样的可以定义泛型\n\n```ts\nclass DataManager<T> {\n  constructor(private data: T[]) {}\n  getItem(index: number) {\n    return this.data[index];\n  }\n}\nconst myData = new DataManager<number>([1, 2, 3]);\nconsole.log(myData.getItem(2));\n```\n\n### 泛型的继承\n\n泛型可以继承自接口\n\n```ts\ninterface Item {\n  name: string;\n}\n\nclass DataManager<T extends Item> {\n  constructor(private data: T[]) {}\n  getItem(index: number): string {\n    return this.data[index].name;\n  }\n}\nconst myData = new DataManager([\n  {\n    name: \"xfy\",\n  },\n]);\nconsole.log(myData.getItem(0));\n```\n\n### 作为类型注解\n\n泛型也可以作为一个具体的类型注解\n\n```ts\nconst xfy = <T>(params: T): T => {\n  return params;\n};\n```\n\n## namespace\n\n命名空间，可以直接为指定的代码生成作用域。并导出需要的代码。\n\n```ts\nnamespace Home {\n  class Header {\n    constructor() {\n      const header = document.createElement(\"header\");\n      header.textContent = `Here is head.`;\n      document.body.append(header);\n    }\n  }\n  class Content {\n    constructor() {\n      const div = document.createElement(\"div\");\n      div.textContent = `Here is content.`;\n      document.body.append(div);\n    }\n  }\n  class Footer {\n    constructor() {\n      const footer = document.createElement(\"footer\");\n      footer.textContent = `© 2021 xfy`;\n      document.body.append(footer);\n    }\n  }\n  export class Page {\n    constructor() {\n      new Header();\n      new Content();\n      new Footer();\n    }\n  }\n}\n```\n\n命名空间也可以在多个文件之间相互导入导出，就和模块系统类似。但使用了命名空间之间的互相导入之后，需要在`tsconfig.json`中修改模块系统为`amd`或`system`。\n\n使用依赖注释：\n\n```ts\n///<reference path='./test.ts' />\n```\n\n","desc":"类型\n\n\n\n基本类型\n\n当复制和变量定义不在同一行时，ts 就无法推断类型。\n\n\n\n引用值\n\n数组，对象，类，函数\n\n函数返回类型\n\n函数也可以指定返回值的静态类型\n\n\n\n如果没有返回值，则使用voi...","title":"TypeScript临碎笔记","date":"2021-06-02T12:13:06.000Z","tags":"TypeScript","categories":"笔记","url":"typescript-pieces","index_img":"/images/TypeScript%E4%B8%B4%E7%A2%8E%E7%AC%94%E8%AE%B0/logo.svg"}},"__N_SSG":true}