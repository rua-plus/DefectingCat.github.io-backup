{"pageProps":{"postData":{"id":"mobile-slidershow","content":"\n## 迫害移动端\n\n继上次的[经典轮播图的实现方案](/defect/classic-slider-show.html)，这次配合了`TouchEvent`来实现了移动端的触摸轮播图。\n\n这次原生的实现方式和 Vue 基本相同，由于需要实现触摸滑动，仅仅靠`absolute`定位和 Vue 的过渡动画是不够的。所以使用了经典的图片队列，然后克隆两张图片来调换队列。\n\n## 封装组件\n\n这次把整个轮播图图都尝试封装成一个单独的组件，图片的队列和动画延时都由父组件传递 props 过来。\n\n```html\n<TouchSlider :images=\"images\" :animeTime=\"'500'\" />\n```\n\n组件内：\n\n```js\n  props: {\n    // 图片队列\n    images: Array,\n    // 动画时间\n    animeTime: String\n  },\n```\n\n## 经典方案的实现\n\n虽然是用 Vue 来实现的方案，但本质上还是将经典方案封装成一个组件，然后配合上`TouchEvent`来实现了移动端的触摸轮播图。\n\n所以第一步还是先使用 Vue 的方式实现经典的布局方案。\n\n### 布局\n\n组件内的布局和之前的经典方案一模一样，外部的 div 使用`relative`定位，内部的 ul 通过`transform`来进行位移。\n\n```html\n<div class=\"slider\">\n  <ul class=\"wrapper\">\n    <!-- v-for 循环的图片 --> \n    <li></li>\n  </ul>\n</div>\n```\n\n与上次不同的地方是这次 ul 使用的`flex`布局，而不是针对 li 使用`flot`。相对于使用浮动`flot`来说，`flex`布局更加好控制，也更先进。\n\n```css\n.slider {\n  position: relative;\n  overflow: hidden;\n}\n.wrapper {\n  display: flex;\n}\n```\n\n### 克隆图片\n\n在 Vue 里就不那么依赖操作 DOM 了，克隆第一张和最后一张图片也很方便，，对传过来的图片数组取第一个和最后一个项目就可以了。\n\n整个图片的队列通过`v-for`来循环生成。\n\n```html\n<!-- 克隆最后一张图片 -->\n<li>\n  <img :src=\"images[images.length - 1].src\" alt=\"\" class=\"roll-img\" />\n</li>\n<li v-for=\"item in images\" :key=\"'img' + item.id\">\n  <img :src=\"item.src\" alt=\"\" class=\"roll-img\" ref=\"img\" />\n</li>\n<!-- 克隆第一张图片 -->\n<li>\n  <img :src=\"images[0].src\" alt=\"\" class=\"roll-img\" />\n</li>\n```\n\n### 队列宽度\n\n经典方案还有个重点就是整个 ul 队列的宽度，它配额偏移量才能准确实现图片的移动。\n\n这里给图片`<img>`都上了一个样式，用来决定图片的宽度：\n\n```css\n.roll-img {\n  width: 600px;\n}\n```\n\n同时还用了个媒体查询，虽然不能做到实时的响应式，但是根据不同的设备还是能做的刷新后适配不同的设备端的。\n\n```css\n@media only screen and (max-width: 376px) {\n  .roll-img {\n    width: 375px;\n  }\n}\n```\n\n既然图片的宽度确定了，那整个 ul 的宽度就是`单张图片的宽度 * 图片的数量`了。\n\n```html\n<ul\n  class=\"wrapper\"\n  :style=\"{\n    width: imgWidth * images.length + 'px'\n  }\"\n></ul>\n```\n\n图片的数量`images.length`很容易确定，单张图片的宽度需要使用 HTMLElement 上的`HTMLElement.offsetWidth`方法。它能返回一个元素的布局宽度，这里使用它来获取单个`<img>`的宽度。获取的时机就在组件被挂载时：\n\n```js\nmounted() {\n  // 计算单个图片的宽度，做移动端适配\n  this.imgWidth = this.$refs.img[0].offsetWidth;\n}\n```\n\n现在在`data()`中还只保存了单张图片宽度`imgWidth`，慢慢来，它会越来越多的。\n\n```js\ndata() {\n  return {\n    // 单张图片的宽度\n    imgWidth: 0,\n  };\n```\n\n### 移动方法\n\n这次依然使用`transition`过渡来实现移动的动画，控制位置使用`translateX`。\n\n第一步先封装一个移动的方法，用了前两次的经验，这次修改了移动图片的方法，并且它接受一个参数，用于判断是否开启过渡动画：\n\n```js\nmove(anime) {\n  // 移动方法，添加过渡动画，根据图片序列移动图片\n  if (anime) {\n    this.transitionX = `all ${this.animeTime}ms`;\n  } else {\n    this.transitionX = `none`;\n  }\n  this.translateX = -(this.imgWidth + this.imgWidth * this.imgIndex);\n}\n```\n\n图片移动的距离也使用了一种更好的公式：`-(单张图片的宽度 + 单张图片的宽度 * 当前图片索引)`。\n\n这个公式的好处就是队列的位移由图片的索引进行驱动，当需要修改队列的位移的位置时，只需要相应的修改索引值，然后调用移动方法内的公式即可。\n\n![](../images/移动端触摸轮播图/2021-02-23-11-23-15.webp)\n\n### 默认位置\n\n上述在`mounted()`挂载后获取了图片的宽度，现在还需要增加一个在挂载后修改下队列的位置。当克隆了两张图片分别在队列的前后时，队列的默认位置需要向左偏移一个图片的宽度。\n\n现在在`data()`中还要再保存一个图片的索引。\n\n```js\ndata() {\n  return {\n    // 单张图片的宽度\n    imgWidth: 0,\n    // 图片索引，用于控制位置\n    imgIndex: 0,\n  };\n```\n\n所以在挂载后，图片的索引为0，调用移动方法即可将队列设置为默认的位置：\n\n```js\nmounted() {\n  // 计算单个图片的宽度，做移动端适配\n  this.imgWidth = this.$refs.img[0].offsetWidth;\n  this.move(false);\n}\n```\n\n### 小圆点\n\n按钮封装的非常基本，就是普通的按钮添加两个点击事件，分别用于操作图片索引加减。这里就不再多说了。\n\n按钮的方法：\n\n```js\nprevious() {\n  if (Date.now() - this.flag > Number(this.animeTime) + 10) {\n    this.imgIndex--;\n    this.move(true);\n    this.flag = Date.now();\n  }\n},\nnext() {\n  if (Date.now() - this.flag > Number(this.animeTime) + 10) {\n    this.imgIndex++;\n    this.move(true);\n    this.flag = Date.now();\n  }\n},\n```\n\n小圆点也不是非常的复杂，简单封装一个`<ol><li></li></ol>`的结构即可。在父组件中通过`v-for`来循环生成 li，顺便绑定 images 的 index 到 li 的 id 上，用于点击事件。\n\n```html\n<IndexPoint\n  class=\"index-point\"\n  :num=\"images.length\"\n  @pointClick=\"pointClick\"\n>\n  <template>\n    <li\n      v-for=\"(item, index) in images\"\n      :key=\"'point' + item.id\"\n      :class=\"{ active: index == pointIndex }\"\n      :id=\"index\"\n    ></li>\n  </template>\n</IndexPoint>\n```\n\n在点击事件里，将点击的小圆点的 id 赋值到图片的索引，然后再调用`move()`方法就可以正确的移动到对于的图片上。\n\n```js\npointClick(e) {\n  this.imgIndex = e.target.id;\n  this.move(true);\n},\n```\n\n### 无限循环\n\n轮播图的重点就在于能够无限轮播，这里使用的还是和往期一样的方案：当移动到克隆的图片时，偷偷替换图片队列。不同的是，这次没有使用`setTimeOut`来进行延时调换，而是使用了`transitionend`事件。该事件就是监听过渡动画完成后调用方法。\n\n监听的方法还是和以前一样，通过判断图片的索引来确定是否是克隆的图片，然后偷偷调换队列。\n\n```js\n    transEnd() {\n      if (this.imgIndex == -1) {\n        // 如果当前序列等于 -1，也就是克隆的图片，则偷偷调整图片队列\n        this.imgIndex = this.images.length - 1;\n        this.move(false);\n      } else if (this.imgIndex == this.images.length) {\n        // 反之亦然\n        this.imgIndex = 0;\n        this.move(false);\n      }\n    },\n```\n\n### 自动播放\n\n自动播放实现的也很简单，定时操作图片的索引即可。\n\n不过这里遇到一个小 Bug，当 Chrome 在后台时，`transitionend`事件不会被监听。这就会导致使用了自动播放在后台放一会之后，所有的图片都消失了。\n\n后来研究了下可以通过[`document.visibilityState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState)判断浏览器是否处于后台，当其值不等于`hidden`时，就继续播放。\n\n```js\n    autoPlay() {\n      this.timer = setInterval(() => {\n        // 当页面处于后台时，transEnd会失效\n        if (document.visibilityState != 'hidden') {\n          this.imgIndex++;\n          this.move(true);\n        }\n        console.log(document.visibilityState);\n      }, 3000);\n    },\n```\n\n```\nvisible\n5 hidden\nvisible\n```\n\n## 触摸事件\n\n上述方法都是将以前实现的经典方案封装到 Vue 组件里，本次的重点还是触摸的滑动方法。\n\n触摸由三个事件组成：从 touchstart 到 touchmove 到 touchend。他们分别对应动作：触摸开始、触摸移动和触摸结束。每一次的触摸都会触发这三个事件。\n\n[触摸事件](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events)有个事件对象`touches`，它就是实现图片移动的主要原理。`touches`内保存这触摸时的坐标，在不同的触摸事件里可以根据坐标来移动图片。\n\n所以这里现在 ul 上绑定对应的三个事件：\n\n```html\n<ul\n  class=\"wrapper\"\n  :style=\"{\n    width: imgWidth * images.length + 'px',\n  }\"\n  @touchstart=\"touchStart\"\n  @touchmove=\"touchMove\"\n  @touchend=\"touchEnd\"\n>\n```\n\n### 触摸开始\n\n第一个是触摸开始的阶段，当第一次触摸到 ul 时，就会触发这个事件。这个事件非常简单，就保存了两个关键的数据：点击时的 X 坐标和当前的图片位置。方便在移动时判断对应的移动位置。\n\n```js\ntouchStart(e) {\n  this.pausePlay();\n  // 触摸开始\n  if (Date.now() - this.flag > Number(this.animeTime) + 10) {\n    // 获取点击时的 X 坐标\n    this.startX = e.touches[0].clientX;\n    // 点击开始时保存当前图片的位置\n    this.lastX = this.translateX;\n  }\n},\n```\n\n### 触摸移动\n\n图片移动的位置就是`原先的位置 + 滑动的距离`。首先判断滑动的距离，使用当前`touchMove`的 X 坐标减去`touchStart`所保存的 X 坐标，就能轻松得出移动了多少距离。\n\n然后再将图片的过渡动画取消`this.transitionX = 'none';`，再给图片添加上移动的距离`this.translateX = this.lastX + this.moveX;`\n\n这里还做了一个简单的判断，当滑动的距离大于单张图片的宽度时`this.moveX >= this.imgWidth`，就不允许再移动了`this.moveX = this.imgWidth;`。同样使用正负值来判断左右移动的方向`this.moveX < 0 && this.moveX <= -this.imgWidth`。\n\n```js\ntouchMove(e) {\n  // 防止在一定时间内过渡滑动\n  if (Date.now() - this.flag > Number(this.animeTime) + 10) {\n    // 移动时的坐标减去点击时的坐标等于移动的距离\n    this.moveX = e.touches[0].clientX - this.startX;\n    // 移动图片\n    this.transitionX = `none`;\n    // 防止滑动过渡\n    if (this.moveX >= this.imgWidth) {\n      this.moveX = this.imgWidth;\n      // 滑动位置等于上次的位置加上手指移动的距离\n      this.translateX = this.lastX + this.moveX;\n    } else if (this.moveX < 0 && this.moveX <= -this.imgWidth) {\n      this.moveX = -this.imgWidth;\n      this.translateX = this.lastX + this.moveX;\n    } else {\n      this.translateX = this.lastX + this.moveX;\n    }\n  }\n},\n```\n\n### 触摸结束\n\n当图片正确的移动后，触摸结束的事件就是对图片做一些判断，保证队列是预期的状态。\n\n第一个判断就是当滑动了整张图片时，不需要再调用`move()`方法了，直接对左右方向进行判断，确定图片的索引加减`this.moveX > 0 ? this.imgIndex-- : this.imgIndex++;`。不过还得再调用一次` this.transEnd()`方法来偷偷调换图片队列。\n\n```js\n    touchEnd() {\n      if (Date.now() - this.flag > Number(this.animeTime) + 10) {\n        // 防止滑动过渡\n        if (this.moveX == this.imgWidth || this.moveX == -this.imgWidth) {\n          this.moveX > 0 ? this.imgIndex-- : this.imgIndex++;\n          // 当越界时，调用恢复队列\n          this.transEnd();\n          // 当触摸大于 70 像素，触发移动动画，移动完整图片\n        } else if (this.moveX > 70) {\n          this.imgIndex--;\n          this.move(true);\n          // 当触摸小于 -70 像素，触发移动动画，移动完整图片\n        } else if (this.moveX < -70) {\n          this.imgIndex++;\n          this.move(true);\n          // 当在二者之间时，图片归位\n        } else {\n          this.move(true);\n        }\n        this.startX = 0;\n        this.moveX = 0;\n        this.flag = Date.now();\n      }\n      this.autoPlay();\n    },\n```\n\n## 🚀\n\n这就是在之前的轮播图上加以实现的移动端轮播图方案，还有一些小方法就没有多嘴了。\n\n几个方法写的比较冗余，感觉可以再简单一点。主要的是对这个组件封装的很烂，整个`TouchSlider.vue`一大串。\n\n[项目地址](https://git.defectink.com/xfy/vue-touch-slider)","desc":"迫害移动端\n\n继上次的经典轮播图的实现方案，这次配合了TouchEvent来实现了移动端的触摸轮播图。\n\n这次原生的实现方式和 Vue 基本相同，由于需要实现触摸滑动，仅仅靠absolute定位和 V...","title":"移动端触摸轮播图","date":"2021-02-23T08:57:10.000Z","tags":["Vue","JavaScript"],"categories":"实践","url":"mobile-slidershow","index_img":"/images/移动端触摸轮播图/logo.webp"}},"__N_SSG":true}