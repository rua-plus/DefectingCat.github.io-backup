<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="shortcut icon" href="/images/img/favicon.webp"/><meta name="keywords" content="Blog RUA"/><meta name="description" content="Personal blog."/><meta name="author" content="Arthur,i@rua.plus"/><title>RUA - TypeScript临碎笔记</title><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/39834862c769c308.css" as="style"/><link rel="stylesheet" href="/_next/static/css/39834862c769c308.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><link rel="preload" href="/_next/static/css/6e1d66a70b5d9fed.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e1d66a70b5d9fed.css"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script defer="" src="/_next/static/chunks/219-ddf2abc0472da9bd.js"></script><script defer="" src="/_next/static/chunks/419.d5302bfd9d8378c2.js"></script><script defer="" src="/_next/static/chunks/771.84a2737df445ba88.js"></script><script defer="" src="/_next/static/chunks/929.b2c0b4f7606bfefe.js"></script><script defer="" src="/_next/static/chunks/125.4ff7adc183744312.js"></script><script defer="" src="/_next/static/chunks/780.f3b2fc2ce5caea55.js"></script><script defer="" src="/_next/static/chunks/980.41f5e97cd35a6621.js"></script><script defer="" src="/_next/static/chunks/106.7a94988fd220337e.js"></script><script defer="" src="/_next/static/chunks/485-3e3bf066e6f4a6bd.js"></script><script defer="" src="/_next/static/chunks/189.ee2e569101c160eb.js"></script><script src="/_next/static/chunks/webpack-c08977534ec7c137.js" defer=""></script><script src="/_next/static/chunks/framework-5cd9e2157a4a6aee.js" defer=""></script><script src="/_next/static/chunks/main-472dbb675bbf7f67.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a34fa0ed9496fbe8.js" defer=""></script><script src="/_next/static/chunks/84-43981acebe84e1d3.js" defer=""></script><script src="/_next/static/chunks/pages/p/%5Bslug%5D-684bfb16186b52fe.js" defer=""></script><script src="/_next/static/k6NIc4JfXUsE09z9QnALx/_buildManifest.js" defer=""></script><script src="/_next/static/k6NIc4JfXUsE09z9QnALx/_ssgManifest.js" defer=""></script><script src="/_next/static/k6NIc4JfXUsE09z9QnALx/_middlewareManifest.js" defer=""></script></head><body><script>(function setScript(initialValue) {
  var mql = window.matchMedia("(prefers-color-scheme: dark)");
  var systemPreference = mql.matches ? "dark" : "light";
  var persistedPreference;

  try {
    persistedPreference = localStorage.getItem("chakra-ui-color-mode");
  } catch (error) {
    console.log("Chakra UI: localStorage is not available. Color mode persistence might not work as expected");
  }

  var isInStorage = typeof persistedPreference === "string";
  var colorMode;

  if (isInStorage) {
    colorMode = persistedPreference;
  } else {
    colorMode = initialValue === "system" ? systemPreference : initialValue;
  }

  if (colorMode) {
    var root = document.documentElement;
    root.style.setProperty("--chakra-ui-color-mode", colorMode);
  }
})('light')</script><div id="__next"><style data-emotion="css-global 1r47v8">:host,:root{--chakra-ring-inset:var(--chakra-empty,/*!*/ /*!*/);--chakra-ring-offset-width:0px;--chakra-ring-offset-color:#fff;--chakra-ring-color:rgba(66, 153, 225, 0.6);--chakra-ring-offset-shadow:0 0 #0000;--chakra-ring-shadow:0 0 #0000;--chakra-space-x-reverse:0;--chakra-space-y-reverse:0;--chakra-colors-transparent:transparent;--chakra-colors-current:currentColor;--chakra-colors-black:#000000;--chakra-colors-white:#FFFFFF;--chakra-colors-whiteAlpha-50:rgba(255, 255, 255, 0.04);--chakra-colors-whiteAlpha-100:rgba(255, 255, 255, 0.06);--chakra-colors-whiteAlpha-200:rgba(255, 255, 255, 0.08);--chakra-colors-whiteAlpha-300:rgba(255, 255, 255, 0.16);--chakra-colors-whiteAlpha-400:rgba(255, 255, 255, 0.24);--chakra-colors-whiteAlpha-500:rgba(255, 255, 255, 0.36);--chakra-colors-whiteAlpha-600:rgba(255, 255, 255, 0.48);--chakra-colors-whiteAlpha-700:rgba(255, 255, 255, 0.64);--chakra-colors-whiteAlpha-800:rgba(255, 255, 255, 0.80);--chakra-colors-whiteAlpha-900:rgba(255, 255, 255, 0.92);--chakra-colors-blackAlpha-50:rgba(0, 0, 0, 0.04);--chakra-colors-blackAlpha-100:rgba(0, 0, 0, 0.06);--chakra-colors-blackAlpha-200:rgba(0, 0, 0, 0.08);--chakra-colors-blackAlpha-300:rgba(0, 0, 0, 0.16);--chakra-colors-blackAlpha-400:rgba(0, 0, 0, 0.24);--chakra-colors-blackAlpha-500:rgba(0, 0, 0, 0.36);--chakra-colors-blackAlpha-600:rgba(0, 0, 0, 0.48);--chakra-colors-blackAlpha-700:rgba(0, 0, 0, 0.64);--chakra-colors-blackAlpha-800:rgba(0, 0, 0, 0.80);--chakra-colors-blackAlpha-900:rgba(0, 0, 0, 0.92);--chakra-colors-gray-50:#F7FAFC;--chakra-colors-gray-100:#EDF2F7;--chakra-colors-gray-200:#E2E8F0;--chakra-colors-gray-300:#CBD5E0;--chakra-colors-gray-400:#A0AEC0;--chakra-colors-gray-500:#718096;--chakra-colors-gray-600:#4A5568;--chakra-colors-gray-700:#2D3748;--chakra-colors-gray-800:#1A202C;--chakra-colors-gray-900:#171923;--chakra-colors-red-50:#FFF5F5;--chakra-colors-red-100:#FED7D7;--chakra-colors-red-200:#FEB2B2;--chakra-colors-red-300:#FC8181;--chakra-colors-red-400:#F56565;--chakra-colors-red-500:#E53E3E;--chakra-colors-red-600:#C53030;--chakra-colors-red-700:#9B2C2C;--chakra-colors-red-800:#822727;--chakra-colors-red-900:#63171B;--chakra-colors-orange-50:#FFFAF0;--chakra-colors-orange-100:#FEEBC8;--chakra-colors-orange-200:#FBD38D;--chakra-colors-orange-300:#F6AD55;--chakra-colors-orange-400:#ED8936;--chakra-colors-orange-500:#DD6B20;--chakra-colors-orange-600:#C05621;--chakra-colors-orange-700:#9C4221;--chakra-colors-orange-800:#7B341E;--chakra-colors-orange-900:#652B19;--chakra-colors-yellow-50:#FFFFF0;--chakra-colors-yellow-100:#FEFCBF;--chakra-colors-yellow-200:#FAF089;--chakra-colors-yellow-300:#F6E05E;--chakra-colors-yellow-400:#ECC94B;--chakra-colors-yellow-500:#D69E2E;--chakra-colors-yellow-600:#B7791F;--chakra-colors-yellow-700:#975A16;--chakra-colors-yellow-800:#744210;--chakra-colors-yellow-900:#5F370E;--chakra-colors-green-50:#F0FFF4;--chakra-colors-green-100:#C6F6D5;--chakra-colors-green-200:#9AE6B4;--chakra-colors-green-300:#68D391;--chakra-colors-green-400:#48BB78;--chakra-colors-green-500:#38A169;--chakra-colors-green-600:#2F855A;--chakra-colors-green-700:#276749;--chakra-colors-green-800:#22543D;--chakra-colors-green-900:#1C4532;--chakra-colors-teal-50:#E6FFFA;--chakra-colors-teal-100:#B2F5EA;--chakra-colors-teal-200:#81E6D9;--chakra-colors-teal-300:#4FD1C5;--chakra-colors-teal-400:#38B2AC;--chakra-colors-teal-500:#319795;--chakra-colors-teal-600:#2C7A7B;--chakra-colors-teal-700:#285E61;--chakra-colors-teal-800:#234E52;--chakra-colors-teal-900:#1D4044;--chakra-colors-blue-50:#ebf8ff;--chakra-colors-blue-100:#bee3f8;--chakra-colors-blue-200:#90cdf4;--chakra-colors-blue-300:#63b3ed;--chakra-colors-blue-400:#4299e1;--chakra-colors-blue-500:#3182ce;--chakra-colors-blue-600:#2b6cb0;--chakra-colors-blue-700:#2c5282;--chakra-colors-blue-800:#2a4365;--chakra-colors-blue-900:#1A365D;--chakra-colors-cyan-50:#EDFDFD;--chakra-colors-cyan-100:#C4F1F9;--chakra-colors-cyan-200:#9DECF9;--chakra-colors-cyan-300:#76E4F7;--chakra-colors-cyan-400:#0BC5EA;--chakra-colors-cyan-500:#00B5D8;--chakra-colors-cyan-600:#00A3C4;--chakra-colors-cyan-700:#0987A0;--chakra-colors-cyan-800:#086F83;--chakra-colors-cyan-900:#065666;--chakra-colors-purple-50:#FAF5FF;--chakra-colors-purple-100:#E9D8FD;--chakra-colors-purple-200:#D6BCFA;--chakra-colors-purple-300:#B794F4;--chakra-colors-purple-400:#9F7AEA;--chakra-colors-purple-500:#805AD5;--chakra-colors-purple-600:#6B46C1;--chakra-colors-purple-700:#553C9A;--chakra-colors-purple-800:#44337A;--chakra-colors-purple-900:#322659;--chakra-colors-pink-50:#FFF5F7;--chakra-colors-pink-100:#FED7E2;--chakra-colors-pink-200:#FBB6CE;--chakra-colors-pink-300:#F687B3;--chakra-colors-pink-400:#ED64A6;--chakra-colors-pink-500:#D53F8C;--chakra-colors-pink-600:#B83280;--chakra-colors-pink-700:#97266D;--chakra-colors-pink-800:#702459;--chakra-colors-pink-900:#521B41;--chakra-colors-linkedin-50:#E8F4F9;--chakra-colors-linkedin-100:#CFEDFB;--chakra-colors-linkedin-200:#9BDAF3;--chakra-colors-linkedin-300:#68C7EC;--chakra-colors-linkedin-400:#34B3E4;--chakra-colors-linkedin-500:#00A0DC;--chakra-colors-linkedin-600:#008CC9;--chakra-colors-linkedin-700:#0077B5;--chakra-colors-linkedin-800:#005E93;--chakra-colors-linkedin-900:#004471;--chakra-colors-facebook-50:#E8F4F9;--chakra-colors-facebook-100:#D9DEE9;--chakra-colors-facebook-200:#B7C2DA;--chakra-colors-facebook-300:#6482C0;--chakra-colors-facebook-400:#4267B2;--chakra-colors-facebook-500:#385898;--chakra-colors-facebook-600:#314E89;--chakra-colors-facebook-700:#29487D;--chakra-colors-facebook-800:#223B67;--chakra-colors-facebook-900:#1E355B;--chakra-colors-messenger-50:#D0E6FF;--chakra-colors-messenger-100:#B9DAFF;--chakra-colors-messenger-200:#A2CDFF;--chakra-colors-messenger-300:#7AB8FF;--chakra-colors-messenger-400:#2E90FF;--chakra-colors-messenger-500:#0078FF;--chakra-colors-messenger-600:#0063D1;--chakra-colors-messenger-700:#0052AC;--chakra-colors-messenger-800:#003C7E;--chakra-colors-messenger-900:#002C5C;--chakra-colors-whatsapp-50:#dffeec;--chakra-colors-whatsapp-100:#b9f5d0;--chakra-colors-whatsapp-200:#90edb3;--chakra-colors-whatsapp-300:#65e495;--chakra-colors-whatsapp-400:#3cdd78;--chakra-colors-whatsapp-500:#22c35e;--chakra-colors-whatsapp-600:#179848;--chakra-colors-whatsapp-700:#0c6c33;--chakra-colors-whatsapp-800:#01421c;--chakra-colors-whatsapp-900:#001803;--chakra-colors-twitter-50:#E5F4FD;--chakra-colors-twitter-100:#C8E9FB;--chakra-colors-twitter-200:#A8DCFA;--chakra-colors-twitter-300:#83CDF7;--chakra-colors-twitter-400:#57BBF5;--chakra-colors-twitter-500:#1DA1F2;--chakra-colors-twitter-600:#1A94DA;--chakra-colors-twitter-700:#1681BF;--chakra-colors-twitter-800:#136B9E;--chakra-colors-twitter-900:#0D4D71;--chakra-colors-telegram-50:#E3F2F9;--chakra-colors-telegram-100:#C5E4F3;--chakra-colors-telegram-200:#A2D4EC;--chakra-colors-telegram-300:#7AC1E4;--chakra-colors-telegram-400:#47A9DA;--chakra-colors-telegram-500:#0088CC;--chakra-colors-telegram-600:#007AB8;--chakra-colors-telegram-700:#006BA1;--chakra-colors-telegram-800:#005885;--chakra-colors-telegram-900:#003F5E;--chakra-colors-home-bg:#f5f5fa;--chakra-borders-none:0;--chakra-borders-1px:1px solid;--chakra-borders-2px:2px solid;--chakra-borders-4px:4px solid;--chakra-borders-8px:8px solid;--chakra-fonts-heading:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--chakra-fonts-body:-apple-system,BlinkMacSystemFont,'Helvetica Neue',Helvetica,Segoe UI,Arial,Roboto,'PingFang SC',miui,'Hiragino Sans GB','Microsoft Yahei',sans-serif;--chakra-fonts-mono:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--chakra-fontSizes-xs:0.75rem;--chakra-fontSizes-sm:0.875rem;--chakra-fontSizes-md:1rem;--chakra-fontSizes-lg:1.125rem;--chakra-fontSizes-xl:1.25rem;--chakra-fontSizes-2xl:1.5rem;--chakra-fontSizes-3xl:1.875rem;--chakra-fontSizes-4xl:2.25rem;--chakra-fontSizes-5xl:3rem;--chakra-fontSizes-6xl:3.75rem;--chakra-fontSizes-7xl:4.5rem;--chakra-fontSizes-8xl:6rem;--chakra-fontSizes-9xl:8rem;--chakra-fontWeights-hairline:100;--chakra-fontWeights-thin:200;--chakra-fontWeights-light:300;--chakra-fontWeights-normal:400;--chakra-fontWeights-medium:500;--chakra-fontWeights-semibold:600;--chakra-fontWeights-bold:700;--chakra-fontWeights-extrabold:800;--chakra-fontWeights-black:900;--chakra-letterSpacings-tighter:-0.05em;--chakra-letterSpacings-tight:-0.025em;--chakra-letterSpacings-normal:0;--chakra-letterSpacings-wide:0.025em;--chakra-letterSpacings-wider:0.05em;--chakra-letterSpacings-widest:0.1em;--chakra-lineHeights-3:.75rem;--chakra-lineHeights-4:1rem;--chakra-lineHeights-5:1.25rem;--chakra-lineHeights-6:1.5rem;--chakra-lineHeights-7:1.75rem;--chakra-lineHeights-8:2rem;--chakra-lineHeights-9:2.25rem;--chakra-lineHeights-10:2.5rem;--chakra-lineHeights-normal:normal;--chakra-lineHeights-none:1;--chakra-lineHeights-shorter:1.25;--chakra-lineHeights-short:1.375;--chakra-lineHeights-base:1.5;--chakra-lineHeights-tall:1.625;--chakra-lineHeights-taller:2;--chakra-radii-none:0;--chakra-radii-sm:0.125rem;--chakra-radii-base:0.25rem;--chakra-radii-md:0.375rem;--chakra-radii-lg:0.5rem;--chakra-radii-xl:0.75rem;--chakra-radii-2xl:1rem;--chakra-radii-3xl:1.5rem;--chakra-radii-full:9999px;--chakra-space-1:0.25rem;--chakra-space-2:0.5rem;--chakra-space-3:0.75rem;--chakra-space-4:1rem;--chakra-space-5:1.25rem;--chakra-space-6:1.5rem;--chakra-space-7:1.75rem;--chakra-space-8:2rem;--chakra-space-9:2.25rem;--chakra-space-10:2.5rem;--chakra-space-12:3rem;--chakra-space-14:3.5rem;--chakra-space-16:4rem;--chakra-space-20:5rem;--chakra-space-24:6rem;--chakra-space-28:7rem;--chakra-space-32:8rem;--chakra-space-36:9rem;--chakra-space-40:10rem;--chakra-space-44:11rem;--chakra-space-48:12rem;--chakra-space-52:13rem;--chakra-space-56:14rem;--chakra-space-60:15rem;--chakra-space-64:16rem;--chakra-space-72:18rem;--chakra-space-80:20rem;--chakra-space-96:24rem;--chakra-space-px:1px;--chakra-space-0\.5:0.125rem;--chakra-space-1\.5:0.375rem;--chakra-space-2\.5:0.625rem;--chakra-space-3\.5:0.875rem;--chakra-shadows-xs:0 0 0 1px rgba(0, 0, 0, 0.05);--chakra-shadows-sm:0 1px 2px 0 rgba(0, 0, 0, 0.05);--chakra-shadows-base:0 1px 3px 0 rgba(0, 0, 0, 0.1),0 1px 2px 0 rgba(0, 0, 0, 0.06);--chakra-shadows-md:0 4px 6px -1px rgba(0, 0, 0, 0.1),0 2px 4px -1px rgba(0, 0, 0, 0.06);--chakra-shadows-lg:0 10px 15px -3px rgba(0, 0, 0, 0.1),0 4px 6px -2px rgba(0, 0, 0, 0.05);--chakra-shadows-xl:0 20px 25px -5px rgba(0, 0, 0, 0.1),0 10px 10px -5px rgba(0, 0, 0, 0.04);--chakra-shadows-2xl:0 25px 50px -12px rgba(0, 0, 0, 0.25);--chakra-shadows-outline:0 0 0 3px rgba(66, 153, 225, 0.6);--chakra-shadows-inner:inset 0 2px 4px 0 rgba(0,0,0,0.06);--chakra-shadows-none:none;--chakra-shadows-dark-lg:rgba(0, 0, 0, 0.1) 0px 0px 0px 1px,rgba(0, 0, 0, 0.2) 0px 5px 10px,rgba(0, 0, 0, 0.4) 0px 15px 40px;--chakra-shadows-card:0px 4px 8px rgba(0, 0, 0, 0.04),0px 0px 2px rgba(0, 0, 0, 0.06),0px 0px 1px rgba(0, 0, 0, 0.04);--chakra-sizes-1:0.25rem;--chakra-sizes-2:0.5rem;--chakra-sizes-3:0.75rem;--chakra-sizes-4:1rem;--chakra-sizes-5:1.25rem;--chakra-sizes-6:1.5rem;--chakra-sizes-7:1.75rem;--chakra-sizes-8:2rem;--chakra-sizes-9:2.25rem;--chakra-sizes-10:2.5rem;--chakra-sizes-12:3rem;--chakra-sizes-14:3.5rem;--chakra-sizes-16:4rem;--chakra-sizes-20:5rem;--chakra-sizes-24:6rem;--chakra-sizes-28:7rem;--chakra-sizes-32:8rem;--chakra-sizes-36:9rem;--chakra-sizes-40:10rem;--chakra-sizes-44:11rem;--chakra-sizes-48:12rem;--chakra-sizes-52:13rem;--chakra-sizes-56:14rem;--chakra-sizes-60:15rem;--chakra-sizes-64:16rem;--chakra-sizes-72:18rem;--chakra-sizes-80:20rem;--chakra-sizes-96:24rem;--chakra-sizes-px:1px;--chakra-sizes-0\.5:0.125rem;--chakra-sizes-1\.5:0.375rem;--chakra-sizes-2\.5:0.625rem;--chakra-sizes-3\.5:0.875rem;--chakra-sizes-max:max-content;--chakra-sizes-min:min-content;--chakra-sizes-full:100%;--chakra-sizes-3xs:14rem;--chakra-sizes-2xs:16rem;--chakra-sizes-xs:20rem;--chakra-sizes-sm:24rem;--chakra-sizes-md:28rem;--chakra-sizes-lg:32rem;--chakra-sizes-xl:36rem;--chakra-sizes-2xl:42rem;--chakra-sizes-3xl:48rem;--chakra-sizes-4xl:56rem;--chakra-sizes-5xl:64rem;--chakra-sizes-6xl:72rem;--chakra-sizes-7xl:80rem;--chakra-sizes-8xl:90rem;--chakra-sizes-container-sm:640px;--chakra-sizes-container-md:768px;--chakra-sizes-container-lg:1024px;--chakra-sizes-container-xl:1280px;--chakra-zIndices-hide:-1;--chakra-zIndices-auto:auto;--chakra-zIndices-base:0;--chakra-zIndices-docked:10;--chakra-zIndices-dropdown:1000;--chakra-zIndices-sticky:1100;--chakra-zIndices-banner:1200;--chakra-zIndices-overlay:1300;--chakra-zIndices-modal:1400;--chakra-zIndices-popover:1500;--chakra-zIndices-skipLink:1600;--chakra-zIndices-toast:1700;--chakra-zIndices-tooltip:1800;--chakra-transition-property-common:background-color,border-color,color,fill,stroke,opacity,box-shadow,transform;--chakra-transition-property-colors:background-color,border-color,color,fill,stroke;--chakra-transition-property-dimensions:width,height;--chakra-transition-property-position:left,right,top,bottom;--chakra-transition-property-background:background-color,background-image,background-position;--chakra-transition-easing-ease-in:cubic-bezier(0.4, 0, 1, 1);--chakra-transition-easing-ease-out:cubic-bezier(0, 0, 0.2, 1);--chakra-transition-easing-ease-in-out:cubic-bezier(0.4, 0, 0.2, 1);--chakra-transition-duration-ultra-fast:50ms;--chakra-transition-duration-faster:100ms;--chakra-transition-duration-fast:150ms;--chakra-transition-duration-normal:200ms;--chakra-transition-duration-slow:300ms;--chakra-transition-duration-slower:400ms;--chakra-transition-duration-ultra-slow:500ms;--chakra-blur-none:0;--chakra-blur-sm:4px;--chakra-blur-base:8px;--chakra-blur-md:12px;--chakra-blur-lg:16px;--chakra-blur-xl:24px;--chakra-blur-2xl:40px;--chakra-blur-3xl:64px;}</style><style data-emotion="css-global 1jqlf9g">html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;touch-action:manipulation;}body{position:relative;min-height:100%;font-feature-settings:'kern';}*,*::before,*::after{border-width:0;border-style:solid;box-sizing:border-box;}main{display:block;}hr{border-top-width:1px;box-sizing:content-box;height:0;overflow:visible;}pre,code,kbd,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:1em;}a{background-color:transparent;color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit;}abbr[title]{border-bottom:none;-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration:underline dotted;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;}b,strong{font-weight:bold;}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sub{bottom:-0.25em;}sup{top:-0.5em;}img{border-style:none;}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0;}button,input{overflow:visible;}button,select{text-transform:none;}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0;}fieldset{padding:0.35em 0.75em 0.625em;}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{vertical-align:baseline;}textarea{overflow:auto;}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{-webkit-appearance:none!important;}input[type="number"]{-moz-appearance:textfield;}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px;}[type="search"]::-webkit-search-decoration{-webkit-appearance:none!important;}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}details{display:block;}summary{display:-webkit-box;display:-webkit-list-item;display:-ms-list-itembox;display:list-item;}template{display:none;}[hidden]{display:none!important;}body,blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0;}button{background:transparent;padding:0;}fieldset{margin:0;padding:0;}ol,ul{margin:0;padding:0;}textarea{resize:vertical;}button,[role="button"]{cursor:pointer;}button::-moz-focus-inner{border:0!important;}table{border-collapse:collapse;}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;}img,svg,video,canvas,audio,iframe,embed,object{display:block;}img,video{max-width:100%;height:auto;}[data-js-focus-visible] :focus:not([data-focus-visible-added]){outline:none;box-shadow:none;}select::-ms-expand{display:none;}</style><style data-emotion="css-global 1of8e4g">body{font-family:var(--chakra-fonts-body);color:var(--chakra-colors-gray-800);background:var(--chakra-colors-white);transition-property:background-color;transition-duration:var(--chakra-transition-duration-normal);line-height:var(--chakra-lineHeights-base);}*::-webkit-input-placeholder{color:var(--chakra-colors-gray-400);}*::-moz-placeholder{color:var(--chakra-colors-gray-400);}*:-ms-input-placeholder{color:var(--chakra-colors-gray-400);}*::placeholder{color:var(--chakra-colors-gray-400);}*,*::before,::after{border-color:var(--chakra-colors-gray-200);word-wrap:break-word;}html,body{background:var(--chakra-colors-home-bg);}img,#write iframe{-webkit-filter:unset;filter:unset;transition-property:filter;transition-duration:var(--chakra-transition-duration-normal);}div{transition-property:background-color;transition-duration:var(--chakra-transition-duration-normal);}</style><style data-emotion="css 1ghv3an">.css-1ghv3an{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:unset;overflow:auto;-webkit-box-flex-flow:column;-webkit-flex-flow:column;-ms-flex-flow:column;flex-flow:column;-webkit-padding-start:0.5rem;padding-inline-start:0.5rem;-webkit-padding-end:0.5rem;padding-inline-end:0.5rem;}@media screen and (min-width: 30em){.css-1ghv3an{height:unset;-webkit-box-flex-flow:column;-webkit-flex-flow:column;-ms-flex-flow:column;flex-flow:column;}}@media screen and (min-width: 48em){.css-1ghv3an{height:100vh;-webkit-box-flex-flow:row;-webkit-flex-flow:row;-ms-flex-flow:row;flex-flow:row;}}</style><div class="css-1ghv3an"><style data-emotion="css xte4wg">.css-xte4wg{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:unset;white-space:nowrap;vertical-align:middle;outline:2px solid transparent;outline-offset:2px;width:auto;line-height:1.2;border-radius:var(--chakra-radii-md);font-weight:var(--chakra-fontWeights-semibold);transition-property:var(--chakra-transition-property-common);transition-duration:var(--chakra-transition-duration-normal);height:var(--chakra-sizes-12);min-width:var(--chakra-sizes-12);font-size:var(--chakra-fontSizes-lg);-webkit-padding-start:var(--chakra-space-6);padding-inline-start:var(--chakra-space-6);-webkit-padding-end:var(--chakra-space-6);padding-inline-end:var(--chakra-space-6);background:var(--chakra-colors-gray-100);margin-top:1rem;top:3rem;}@media screen and (min-width: 30em){.css-xte4wg{position:unset;margin-top:1rem;}}@media screen and (min-width: 48em){.css-xte4wg{position:-webkit-sticky;position:sticky;margin-top:3rem;}}.css-xte4wg:focus,.css-xte4wg[data-focus]{box-shadow:var(--chakra-shadows-outline);}.css-xte4wg[disabled],.css-xte4wg[aria-disabled=true],.css-xte4wg[data-disabled]{opacity:0.4;cursor:not-allowed;box-shadow:var(--chakra-shadows-none);}.css-xte4wg:hover,.css-xte4wg[data-hover]{background:var(--chakra-colors-gray-200);}.css-xte4wg:hover[disabled],.css-xte4wg[data-hover][disabled],.css-xte4wg:hover[aria-disabled=true],.css-xte4wg[data-hover][aria-disabled=true],.css-xte4wg:hover[data-disabled],.css-xte4wg[data-hover][data-disabled]{background:var(--chakra-colors-gray-100);}.css-xte4wg:active,.css-xte4wg[data-active]{background:var(--chakra-colors-gray-300);}</style><button type="button" class="chakra-button css-xte4wg">BACK</button><style data-emotion="css a06krq">.css-a06krq{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;width:var(--chakra-sizes-full);-webkit-box-flex-flow:column;-webkit-flex-flow:column;-ms-flex-flow:column;flex-flow:column;-webkit-padding-start:unset;padding-inline-start:unset;-webkit-padding-end:unset;padding-inline-end:unset;}@media screen and (min-width: 30em){.css-a06krq{width:var(--chakra-sizes-full);-webkit-padding-start:unset;padding-inline-start:unset;-webkit-padding-end:unset;padding-inline-end:unset;}}@media screen and (min-width: 48em){.css-a06krq{width:55rem;-webkit-padding-start:1.5rem;padding-inline-start:1.5rem;-webkit-padding-end:1.5rem;padding-inline-end:1.5rem;}}@media screen and (min-width: 62em){.css-a06krq{width:55rem;}}@media screen and (min-width: 80em){.css-a06krq{width:55rem;}}@media screen and (min-width: 96em){.css-a06krq{width:68rem;}}</style><div class="css-a06krq"><style data-emotion="css 1if659q">.css-1if659q{border-radius:10px;margin-top:1rem;box-shadow:var(--chakra-shadows-lg);background:var(--chakra-colors-white);overflow:hidden;-webkit-flex:1;-ms-flex:1;flex:1;}@media screen and (min-width: 30em){.css-1if659q{margin-top:1rem;}}@media screen and (min-width: 48em){.css-1if659q{margin-top:3rem;}}</style><div class="css-1if659q"><style data-emotion="css 81xunj">.css-81xunj{padding:1rem;}@media screen and (min-width: 30em){.css-81xunj{padding:1rem;}}@media screen and (min-width: 48em){.css-81xunj{padding:2rem;}}</style><article class="css-81xunj"><header class="css-0"><style data-emotion="css 1m7qnzk">.css-1m7qnzk{font-family:var(--chakra-fonts-heading);font-weight:var(--chakra-fontWeights-bold);font-size:var(--chakra-fontSizes-3xl);line-height:1.33;margin-bottom:1rem;color:rgba(0, 0, 0, 0.85);}@media screen and (min-width: 48em){.css-1m7qnzk{font-size:var(--chakra-fontSizes-4xl);line-height:1.2;}}</style><h1 class="chakra-heading css-1m7qnzk">TypeScript临碎笔记</h1><style data-emotion="css acwcvw">.css-acwcvw{margin-bottom:1rem;}</style><div class="css-acwcvw"><style data-emotion="css 1kpd5c2">.css-1kpd5c2{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;vertical-align:top;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;max-width:100%;font-weight:var(--chakra-fontWeights-medium);line-height:1.2;outline:2px solid transparent;outline-offset:2px;min-height:1.5rem;min-width:1.5rem;font-size:var(--chakra-fontSizes-sm);border-radius:var(--chakra-radii-md);-webkit-padding-start:var(--chakra-space-2);padding-inline-start:var(--chakra-space-2);-webkit-padding-end:var(--chakra-space-2);padding-inline-end:var(--chakra-space-2);background:var(--chakra-colors-gray-100);color:var(--chakra-colors-gray-800);}.css-1kpd5c2:focus,.css-1kpd5c2[data-focus]{box-shadow:var(--chakra-shadows-outline);}</style><span class="css-1kpd5c2">TypeScript</span></div><style data-emotion="css x8djax">.css-x8djax{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--chakra-colors-gray-600);}</style><div class="css-x8djax"><style data-emotion="css 1lr2xj">.css-1lr2xj{width:1em;height:1em;display:inline-block;line-height:1em;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;color:currentColor;margin-right:0.5rem;}</style><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" focusable="false" class="chakra-icon css-1lr2xj" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg><style data-emotion="css 129gw94">.css-129gw94{line-height:0;}</style><time dateTime="2021-06-02T12:13:06.000Z" class="css-129gw94">2021/06/02</time></div></header><style data-emotion="css i51og3">.css-i51og3{margin-top:2rem;}</style><section id="write" class="css-i51og3"><h2 id="类型">类型</h2>
<pre><style data-emotion="css 19bp9bt">.css-19bp9bt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;white-space:nowrap;vertical-align:middle;outline:2px solid transparent;outline-offset:2px;width:auto;line-height:1.2;border-radius:var(--chakra-radii-md);font-weight:var(--chakra-fontWeights-semibold);transition-property:var(--chakra-transition-property-common);transition-duration:var(--chakra-transition-duration-normal);height:var(--chakra-sizes-6);min-width:var(--chakra-sizes-6);font-size:var(--chakra-fontSizes-xs);-webkit-padding-start:var(--chakra-space-2);padding-inline-start:var(--chakra-space-2);-webkit-padding-end:var(--chakra-space-2);padding-inline-end:var(--chakra-space-2);background:var(--chakra-colors-teal-500);color:var(--chakra-colors-white);top:5px;right:5px;}.css-19bp9bt:focus,.css-19bp9bt[data-focus]{box-shadow:var(--chakra-shadows-outline);}.css-19bp9bt[disabled],.css-19bp9bt[aria-disabled=true],.css-19bp9bt[data-disabled]{opacity:0.4;cursor:not-allowed;box-shadow:var(--chakra-shadows-none);}.css-19bp9bt:hover,.css-19bp9bt[data-hover]{background:var(--chakra-colors-teal-600);}.css-19bp9bt:hover[disabled],.css-19bp9bt[data-hover][disabled],.css-19bp9bt:hover[aria-disabled=true],.css-19bp9bt[data-hover][aria-disabled=true],.css-19bp9bt:hover[data-disabled],.css-19bp9bt[data-hover][data-disabled]{background:var(--chakra-colors-teal-500);}.css-19bp9bt:active,.css-19bp9bt[data-active]{background:var(--chakra-colors-teal-700);}</style><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-comment">// 基础类型 null, undefined, symbol, boolean, void</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">123</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">teacherName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Dell&#x27;</span>;

<span class="hljs-comment">// 对象类型</span>

<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Person</span> {}

<span class="hljs-keyword">const</span> <span class="hljs-attr">teacher</span>: {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
} = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dell&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">numbers</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-keyword">const</span> <span class="hljs-attr">dell</span>: <span class="hljs-title hljs-class">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Person</span>();

<span class="hljs-keyword">const</span> <span class="hljs-attr">getTotal</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;
};

</code></pre>
<h3 id="基本类型">基本类型</h3>
<p>当复制和变量定义不在同一行时，ts 就无法推断类型。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-js">string, number
</code></pre>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-js"><span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, symbol, boolean, <span class="hljs-keyword">void</span>
</code></pre>
<h3 id="引用值">引用值</h3>
<p>数组，对象，类，函数</p>
<h2 id="函数返回类型">函数返回类型</h2>
<p>函数也可以指定返回值的静态类型</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">test</span>(<span class="hljs-params">data: { x: <span class="hljs-built_in">number</span> }</span>): <span class="hljs-built_in">object</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(data.<span class="hljs-property">x</span>);
  <span class="hljs-keyword">return</span> data;
}

<span class="hljs-title hljs-function">test</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">123</span> });

</code></pre>
<p>如果没有返回值，则使用<code>void</code>指定</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">test</span>(<span class="hljs-params">data: { x: <span class="hljs-built_in">number</span> }</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(data.<span class="hljs-property">x</span>);
}

<span class="hljs-title hljs-function">test</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">123</span> });

</code></pre>
<h3 id="never">never</h3>
<p>指定<code>never</code>返回值表示该函数永远不会执行完</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">test</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}
}

</code></pre>
<h3 id="解构参数类型注解">解构参数类型注解</h3>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">add</span>(<span class="hljs-params">{
  firstNumber,
  secondNumber,
}: {
  firstNumber: <span class="hljs-built_in">number</span>;
  secondNumber: <span class="hljs-built_in">number</span>;
}</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> firstNumber + secondNumber;
}
<span class="hljs-title hljs-function">add</span>({ <span class="hljs-attr">firstNumber</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">secondNumber</span>: <span class="hljs-number">2</span> });

</code></pre>
<h3 id="匿名函数的类型注解">匿名函数的类型注解</h3>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">const</span> fn = (<span class="hljs-attr">data</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> }): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> data.<span class="hljs-property">x</span>;
};
<span class="hljs-keyword">const</span> <span class="hljs-attr">fnc</span>: <span class="hljs-function">(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span> = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> str;
};

</code></pre>
<h2 id="数组和元组">数组和元组</h2>
<h3 id="数组的类型注解">数组的类型注解</h3>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> <span class="hljs-attr">objArr</span>: <span class="hljs-built_in">object</span>[] = [{}, {}];
<span class="hljs-keyword">const</span> <span class="hljs-attr">obj1Arr</span>: { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }[] = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span> }];
<span class="hljs-keyword">const</span> <span class="hljs-attr">obj2Arr</span>: ({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> } | <span class="hljs-built_in">number</span>)[] = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span> }, <span class="hljs-number">123</span>];

</code></pre>
<h3 id="类型别名">类型别名</h3>
<p>类型别名和<code>interface</code>类似</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title hljs-class">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
};
<span class="hljs-keyword">const</span> <span class="hljs-attr">arr1</span>: <span class="hljs-title hljs-class">User</span>[] = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> }];

<span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">User1</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">const</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title hljs-class">User1</span>[] = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> }];

</code></pre>
<h3 id="元组">元组</h3>
<p>tuple，数据解构和数组类似，但可以指定每一项的数据类型。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>];
<span class="hljs-keyword">const</span> <span class="hljs-attr">csv1</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>][] = [];
</code></pre>
<h2 id="interface">interface</h2>
<p>interface 用于定义一个新的类型集合</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person3</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">const</span> sayName = (<span class="hljs-attr">person</span>: <span class="hljs-title hljs-class">Person3</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(person.<span class="hljs-property">name</span>);
};
<span class="hljs-title hljs-function">sayName</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span> });

</code></pre>
<h3 id="类型别名和interface区别">类型别名和<code>interface</code>区别</h3>
<p>类型别名可以直接指定单个类型，而接口必须为一个对象</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person1</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">type</span> <span class="hljs-title hljs-class">Person2</span> = <span class="hljs-built_in">string</span>;

</code></pre>
<p>能用接口的尽量使用接口来定义。</p>
<h3 id="可选类型">可选类型</h3>
<p>一种类似于可选链的语法，通过 interface 注解可选的数据类型</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person4</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  age?: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">const</span> fn1 = (<span class="hljs-attr">person</span>: <span class="hljs-title hljs-class">Person4</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(person.<span class="hljs-property">name</span>);
};
<span class="hljs-title hljs-function">fn1</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> });
</code></pre>
<h3 id="只读">只读</h3>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person5</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  age?: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">const</span> fn2 = (<span class="hljs-attr">person</span>: <span class="hljs-title hljs-class">Person5</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(person.<span class="hljs-property">name</span>);
  person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;test&#x27;</span>;  <span class="hljs-comment">// Cannot assign to &#x27;name&#x27; because it is a read-only property.</span>
};
<span class="hljs-title hljs-function">fn2</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> });

</code></pre>
<h3 id="强类型检查">强类型检查</h3>
<p>当 interface 注解类型时，通过直接传递对象字面量就会进行强类型检查。ts 会检查对象字面量内的每个属性，多余的属性将无法通过检查。</p>
<p>而通过使用一个对象表达式将一个变量进行传递时，检查不会那么严格。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person6</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  age?: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">const</span> fn3 = (<span class="hljs-attr">person</span>: <span class="hljs-title hljs-class">Person6</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(person.<span class="hljs-property">name</span>);
  <span class="hljs-comment">// person.name = &#x27;test&#x27;;</span>
};
<span class="hljs-title hljs-function">fn3</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;female&#x27;</span> });  <span class="hljs-comment">//  &#x27;sex&#x27; does not exist in type &#x27;Person6&#x27;.</span>
<span class="hljs-keyword">const</span> person1 = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>,
  <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;female&#x27;</span>,
};
<span class="hljs-title hljs-function">fn3</span>(person1);
</code></pre>
<h3 id="其他属性注解">其他属性注解</h3>
<p>通过 interface 直接注解的类型无法传递对象字面量传递未注解的属性，可以使用定义其他变量的类型注解</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person6</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  age?: <span class="hljs-built_in">number</span>;
  [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
}
<span class="hljs-keyword">const</span> fn3 = (<span class="hljs-attr">person</span>: <span class="hljs-title hljs-class">Person6</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(person.<span class="hljs-property">name</span>);
  <span class="hljs-comment">// person.name = &#x27;test&#x27;;</span>
};
<span class="hljs-title hljs-function">fn3</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;female&#x27;</span> });
</code></pre>
<h3 id="注解方法">注解方法</h3>
<p>除了注解指定的属性类型，还可以注解方法，并注解函数的返回值类型</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person6</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  age?: <span class="hljs-built_in">number</span>;
  [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
  <span class="hljs-title hljs-function">say</span>(): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">const</span> fn3 = (<span class="hljs-attr">person</span>: <span class="hljs-title hljs-class">Person6</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(person.<span class="hljs-property">name</span>);
  <span class="hljs-comment">// person.name = &#x27;test&#x27;;</span>
};
<span class="hljs-title hljs-function">fn3</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>,
  <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;female&#x27;</span>,
  <span class="hljs-title hljs-function">say</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;yyy&#x27;</span>;
  },
});
</code></pre>
<h3 id="类">类</h3>
<p>使用 implements 语法</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person6</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  age?: <span class="hljs-built_in">number</span>;
  [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
  <span class="hljs-title hljs-function">say</span>(): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">User2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title hljs-class">Person6</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span>;
  <span class="hljs-title hljs-function">say</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;yyy&#x27;</span>;
  }
}

</code></pre>
<h3 id="接口继承">接口继承</h3>
<p>接口继承的语法与类继承类似</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Person7</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  age?: <span class="hljs-built_in">number</span>;
  [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
  <span class="hljs-title hljs-function">say</span>(): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Teach</span> <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class">Person7</span> {
  <span class="hljs-title hljs-function">teach</span>(): <span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">const</span> test3 = (<span class="hljs-attr">person</span>: <span class="hljs-title hljs-class">Teach</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {};
<span class="hljs-title hljs-function">test3</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xfy&#x27;</span>,
  <span class="hljs-title hljs-function">say</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;yyy&#x27;</span>;
  },
  <span class="hljs-title hljs-function">teach</span>(<span class="hljs-params"></span>) {},
});

</code></pre>
<h2 id="类-1">类</h2>
<p>TypeScript 中为类定义了多个声明关键字。帮助类声明公共与私有属性。</p>
<h3 id="public">public</h3>
<p>默认情况下直接声明的属性是通过 public 声明的，即在外部也能正常访问该属性。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Person</span> {
  name = <span class="hljs-string">&#x27;xfy&#x27;</span>;
  <span class="hljs-title hljs-function">sayName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">name</span>;
  }
}

<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Person</span>();
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-title hljs-function">sayName</span>());
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-property">name</span>);
</code></pre>
<h3 id="private">private</h3>
<p>private 与 public 相对立。通过 private 声明的属性只能在当前类的内部被访问到，即使是继承的子类也无法直接访问。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Person</span> {
  <span class="hljs-keyword">private</span> name = <span class="hljs-string">&#x27;xfy&#x27;</span>;
  <span class="hljs-title hljs-function">sayName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">name</span>;
  }
}

<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Person</span>();
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-title hljs-function">sayName</span>());
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-property">name</span>); <span class="hljs-comment">// Property &#x27;name&#x27; is private and only accessible within class &#x27;Person&#x27;.</span>

<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class hljs-inherited">Person</span> {
  <span class="hljs-title hljs-function">say</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">name</span>;  <span class="hljs-comment">// Property &#x27;name&#x27; is private and only accessible within class &#x27;Person&#x27;.</span>
  }
}

</code></pre>
<h3 id="protected">protected</h3>
<p>与 private 类型，protected 的属性也无法在外部被访问。但是可以在继承的子类中被访问到。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Person</span> {
  <span class="hljs-keyword">private</span> name = <span class="hljs-string">&#x27;xfy&#x27;</span>;
  <span class="hljs-title hljs-function">sayName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">name</span>;
  }
}

<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Person</span>();
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-title hljs-function">sayName</span>());
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-property">name</span>); <span class="hljs-comment">// Property &#x27;name&#x27; is private and only accessible within class &#x27;Person&#x27;.</span>

<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class hljs-inherited">Person</span> {
  <span class="hljs-title hljs-function">say</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">name</span>;  <span class="hljs-comment">// ok</span>
  }
}

</code></pre>
<h3 id="constructor">constructor</h3>
<p>与 JavaScript 的 constructor 不同的是，在 TypeScript 中 constrcutor 需要先在类中定义对应的 public 属性。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">name</span> = name;
  }
}
<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Person</span>(<span class="hljs-string">&#x27;xfy&#x27;</span>);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-property">name</span>);
</code></pre>
<p>为了方便起见，TypeScript 也有简写 constructor 参数的方法。并且不需要再在内部添加<code>this.name</code>了。编译器会帮我们自动生成。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Person</span> {
  <span class="hljs-comment">// name: string;</span>
  <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-comment">// this.name = name;</span>
  }
}
<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Person</span>(<span class="hljs-string">&#x27;xfy&#x27;</span>);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-property">name</span>);

</code></pre>
<p>constructor 继承时的用法与传统 JavaScript 类似。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Person</span> {
  <span class="hljs-comment">// name: string;</span>
  <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-comment">// this.name = name;</span>
  }
}
<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Person</span>(<span class="hljs-string">&#x27;xfy&#x27;</span>);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(xfy.<span class="hljs-property">name</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class hljs-inherited">Person</span> {
  <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable hljs-language">super</span>(name);
  }
}
<span class="hljs-keyword">let</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Teacher</span>(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>);

</code></pre>
<blockquote>
<p>即使父类没有 constructor，子类继承时也需要调用<code>super()</code></p>
</blockquote>
<h3 id="抽象类">抽象类</h3>
<p>在定义多个有相似方法的类时，可以定义一个抽象类来为同样的方法注解类型。抽象类中也可以包含实际的内容。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Geo</span> {
  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">abstract</span> <span class="hljs-title hljs-function">getAare</span>(): <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class hljs-inherited">Geo</span> {
  <span class="hljs-comment">// width = &#x27;123&#x27;;</span>
  width = <span class="hljs-number">123</span>;
  <span class="hljs-title hljs-function">getAare</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class hljs-inherited">Geo</span> {
  <span class="hljs-title hljs-function">getAare</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class hljs-inherited">Geo</span> {
  <span class="hljs-title hljs-function">getAare</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;
  }
}

</code></pre>
<h2 id="单例模式">单例模式</h2>
<p>单例模式（Singleton Pattern）是多数编程软件中常用的设计模式。通过 TypeScript 就可以为 JavaScript 创建一个单例模式的类。</p>
<p>这里通过 private 将 constructor 隐藏在类的内部。在类体上暴露一个方法<code>getInstance()</code>，通过这个方法来获取唯一的实例。同时在类体上还定义一个 private 属性 instance，它的类型注解就是该类。每次调用<code>getInstance()</code>方法时，通过检查 instance 是否有值，没有就创建一个新的实例，并缓存在 instance 内。后续直接返回 instance。这样就能够保证后续创建的实例都是同一个实例。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Demo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title hljs-class">Demo</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {}
  <span class="hljs-keyword">static</span> <span class="hljs-title hljs-function">getInstance</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title hljs-class">Demo</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-title hljs-class">Demo</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Demo</span>(name);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title hljs-class">Demo</span>.<span class="hljs-property">instance</span>;
  }
}
<span class="hljs-keyword">let</span> t1 = <span class="hljs-title hljs-class">Demo</span>.<span class="hljs-title hljs-function">getInstance</span>(<span class="hljs-string">&#x27;xfy&#x27;</span>);
<span class="hljs-keyword">let</span> t2 = <span class="hljs-title hljs-class">Demo</span>.<span class="hljs-title hljs-function">getInstance</span>(<span class="hljs-string">&#x27;dfy&#x27;</span>);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(t1.<span class="hljs-property">name</span>);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(t2.<span class="hljs-property">name</span>);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(t1 === t2);

</code></pre>
<h2 id="dts">.d.ts</h2>
<p>传统的 js 在被引入到 ts 中无法正确的被推断出类型。需要使用<code>.d.ts</code>已经注解好类型的文件来转译。</p>
<p>通常在 @types 里<code>https://www.npmjs.com/package/@types</code></p>
<h3 id="定义全局">定义全局</h3>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    $(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title hljs-function">html</span>(<span class="hljs-string">&#x27;&lt;h1&gt;Hi, there&lt;/h1&gt;&#x27;</span>)
})
</code></pre>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-comment">// 全局变量</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">$</span>: <span class="hljs-function">(<span class="hljs-params">param: () =&gt; <span class="hljs-built_in">void</span></span>)  =&gt;</span> <span class="hljs-built_in">void</span>;
</code></pre>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">JqueryInstance</span> {
    <span class="hljs-attr">html</span>: <span class="hljs-function">(<span class="hljs-params">content: <span class="hljs-built_in">string</span></span>) =&gt;</span> {}
}
<span class="hljs-comment">// 函数重载</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">$</span>(<span class="hljs-params">param: () =&gt; <span class="hljs-built_in">void</span></span>): <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">$</span>(<span class="hljs-params">patam: <span class="hljs-built_in">string</span></span>): <span class="hljs-title hljs-class">JqueryInstance</span>;
</code></pre>
<h2 id="函数重载">函数重载</h2>
<p>使用 interface 的语法，实现函数重载</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> JQuery {
    (<span class="hljs-attr">param</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
    (<span class="hljs-attr">patam</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title hljs-class">JqueryInstance</span>;
}
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">$</span>: JQuery;
</code></pre>
<h2 id="tsconfig">tsconfig</h2>
<p>使用<code>tsc --init</code>初始化一个项目时，会自动生成一个带有注释的<code>tsconfig.json</code>配置文件。这个文件就是对 TypeScript 编译的一些配置文件。</p>
<p>一个默认的配置文件可能是这样的：</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span>

    <span class="hljs-comment">/* Basic Options */</span>
    <span class="hljs-comment">// &quot;incremental&quot;: true,                         /* Enable incremental compilation */</span>
    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ESNEXT&quot;</span><span class="hljs-punctuation">,</span>                                <span class="hljs-comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span>
    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span>                           <span class="hljs-comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span>
    <span class="hljs-comment">// &quot;lib&quot;: [],                                   /* Specify library files to be included in the compilation. */</span>
    <span class="hljs-comment">// &quot;allowJs&quot;: true,                             /* Allow javascript files to be compiled. */</span>
    <span class="hljs-comment">// &quot;checkJs&quot;: true,                             /* Report errors in .js files. */</span>
    <span class="hljs-comment">// &quot;jsx&quot;: &quot;preserve&quot;,                           /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, &#x27;react&#x27;, &#x27;react-jsx&#x27; or &#x27;react-jsxdev&#x27;. */</span>
    <span class="hljs-comment">// &quot;declaration&quot;: true,                         /* Generates corresponding &#x27;.d.ts&#x27; file. */</span>
    <span class="hljs-comment">// &quot;declarationMap&quot;: true,                      /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span>
    <span class="hljs-comment">// &quot;sourceMap&quot;: true,                           /* Generates corresponding &#x27;.map&#x27; file. */</span>
    <span class="hljs-comment">// &quot;outFile&quot;: &quot;./&quot;,                             /* Concatenate and emit output to single file. */</span>
    <span class="hljs-comment">// &quot;outDir&quot;: &quot;./&quot;,                              /* Redirect output structure to the directory. */</span>
    <span class="hljs-comment">// &quot;rootDir&quot;: &quot;./&quot;,                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span>
    <span class="hljs-comment">// &quot;composite&quot;: true,                           /* Enable project compilation */</span>
    <span class="hljs-comment">// &quot;tsBuildInfoFile&quot;: &quot;./&quot;,                     /* Specify file to store incremental compilation information */</span>
    <span class="hljs-comment">// &quot;removeComments&quot;: true,                      /* Do not emit comments to output. */</span>
    <span class="hljs-comment">// &quot;noEmit&quot;: true,                              /* Do not emit outputs. */</span>
    <span class="hljs-comment">// &quot;importHelpers&quot;: true,                       /* Import emit helpers from &#x27;tslib&#x27;. */</span>
    <span class="hljs-comment">// &quot;downlevelIteration&quot;: true,                  /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span>
    <span class="hljs-comment">// &quot;isolatedModules&quot;: true,                     /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span>

    <span class="hljs-comment">/* Strict Type-Checking Options */</span>
    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>                                 <span class="hljs-comment">/* Enable all strict type-checking options. */</span>
    <span class="hljs-comment">// &quot;noImplicitAny&quot;: true,                       /* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span>
    <span class="hljs-comment">// &quot;strictNullChecks&quot;: true,                    /* Enable strict null checks. */</span>
    <span class="hljs-comment">// &quot;strictFunctionTypes&quot;: true,                 /* Enable strict checking of function types. */</span>
    <span class="hljs-comment">// &quot;strictBindCallApply&quot;: true,                 /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span>
    <span class="hljs-comment">// &quot;strictPropertyInitialization&quot;: true,        /* Enable strict checking of property initialization in classes. */</span>
    <span class="hljs-comment">// &quot;noImplicitThis&quot;: true,                      /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span>
    <span class="hljs-comment">// &quot;alwaysStrict&quot;: true,                        /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span>

    <span class="hljs-comment">/* Additional Checks */</span>
    <span class="hljs-comment">// &quot;noUnusedLocals&quot;: true,                      /* Report errors on unused locals. */</span>
    <span class="hljs-comment">// &quot;noUnusedParameters&quot;: true,                  /* Report errors on unused parameters. */</span>
    <span class="hljs-comment">// &quot;noImplicitReturns&quot;: true,                   /* Report error when not all code paths in function return a value. */</span>
    <span class="hljs-comment">// &quot;noFallthroughCasesInSwitch&quot;: true,          /* Report errors for fallthrough cases in switch statement. */</span>
    <span class="hljs-comment">// &quot;noUncheckedIndexedAccess&quot;: true,            /* Include &#x27;undefined&#x27; in index signature results */</span>
    <span class="hljs-comment">// &quot;noPropertyAccessFromIndexSignature&quot;: true,  /* Require undeclared properties from index signatures to use element accesses. */</span>

    <span class="hljs-comment">/* Module Resolution Options */</span>
    <span class="hljs-comment">// &quot;moduleResolution&quot;: &quot;node&quot;,                  /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span>
    <span class="hljs-comment">// &quot;baseUrl&quot;: &quot;./&quot;,                             /* Base directory to resolve non-absolute module names. */</span>
    <span class="hljs-comment">// &quot;paths&quot;: {},                                 /* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span>
    <span class="hljs-comment">// &quot;rootDirs&quot;: [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */</span>
    <span class="hljs-comment">// &quot;typeRoots&quot;: [],                             /* List of folders to include type definitions from. */</span>
    <span class="hljs-comment">// &quot;types&quot;: [],                                 /* Type declaration files to be included in compilation. */</span>
    <span class="hljs-comment">// &quot;allowSyntheticDefaultImports&quot;: true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span>
    <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>                        <span class="hljs-comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span>
    <span class="hljs-comment">// &quot;preserveSymlinks&quot;: true,                    /* Do not resolve the real path of symlinks. */</span>
    <span class="hljs-comment">// &quot;allowUmdGlobalAccess&quot;: true,                /* Allow accessing UMD globals from modules. */</span>

    <span class="hljs-comment">/* Source Map Options */</span>
    <span class="hljs-comment">// &quot;sourceRoot&quot;: &quot;&quot;,                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span>
    <span class="hljs-comment">// &quot;mapRoot&quot;: &quot;&quot;,                               /* Specify the location where debugger should locate map files instead of generated locations. */</span>
    <span class="hljs-comment">// &quot;inlineSourceMap&quot;: true,                     /* Emit a single file with source maps instead of having a separate file. */</span>
    <span class="hljs-comment">// &quot;inlineSources&quot;: true,                       /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span>

    <span class="hljs-comment">/* Experimental Options */</span>
    <span class="hljs-comment">// &quot;experimentalDecorators&quot;: true,              /* Enables experimental support for ES7 decorators. */</span>
    <span class="hljs-comment">// &quot;emitDecoratorMetadata&quot;: true,               /* Enables experimental support for emitting type metadata for decorators. */</span>

    <span class="hljs-comment">/* Advanced Options */</span>
    <span class="hljs-attr">&quot;skipLibCheck&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>                           <span class="hljs-comment">/* Skip type checking of declaration files. */</span>
    <span class="hljs-attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>        <span class="hljs-comment">/* Disallow inconsistently-cased references to the same file. */</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>

</code></pre>
<p>仔细看的话，配置文件内主要包含一个大的字段<code>&quot;compilerOptions&quot;</code>，这是针对编译时的配置。对文件的配置还有<code>include</code>和<code>exclude</code>：</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/config.ts&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
	<span class="hljs-comment">// ...</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>

</code></pre>
<h2 id="联合类型与类型保护">联合类型与类型保护</h2>
<p>当定义了多个 interface 需要同时使用时，可以使用<code>|</code>运算符来同时使用。但是这样也会遇到一个小问题，同时使用两个 interface 时，语法提示只会提示二者共有的类型注解。</p>
<p>因为不能保证传入的参数一定会拥有独有的属性</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Bird</span> {
  <span class="hljs-attr">fly</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">sing</span>: <span class="hljs-function">() =&gt;</span> {};
}
<span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Dog</span> {
  <span class="hljs-attr">fly</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">bark</span>: <span class="hljs-function">() =&gt;</span> {};
}

<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">trainAnimal</span>(<span class="hljs-params">animal: Bird | Dog</span>) {
  <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(animal);
}
</code></pre>
<p><picture data-rmiz-wrap="visible"><style data-emotion="css 185nr5j">.css-185nr5j{object-fit:cover;border-radius:10px;-webkit-filter:blur(20px);filter:blur(20px);transition-duration:var(--chakra-transition-duration-slower);height:100%;}</style><img alt="Post image" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" class="chakra-image css-185nr5j"/><button aria-label="Zoom image" data-rmiz-btn-open="true"></button></picture></p>
<h3 id="类型保护">类型保护</h3>
<p>类型保护有多个方法，作用就是在特定情况下访问独有的属性。</p>
<h4 id="类型断言">类型断言</h4>
<p>断言的目的就是在当前情况下，我非常清楚指定传进来的参数有指定的参数。</p>
<p>假设在当前例子里，参数中的<code>fly</code>属性只要为<code>true</code>时，就一定能确定是<code>Bird</code>接口的类型。那么就可以断言为：</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Bird</span> {
  <span class="hljs-attr">fly</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">sing</span>: <span class="hljs-function">() =&gt;</span> {};
}
<span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Dog</span> {
  <span class="hljs-attr">fly</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">bark</span>: <span class="hljs-function">() =&gt;</span> {};
}

<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">trainAnimal</span>(<span class="hljs-params">animal: Bird | Dog</span>) {
  <span class="hljs-keyword">if</span> (animal.<span class="hljs-property">fly</span>) {
    (animal <span class="hljs-keyword">as</span> <span class="hljs-title hljs-class">Bird</span>).<span class="hljs-title hljs-function">sing</span>();
  }
}
</code></pre>
<h4 id="in语法"><code>in</code>语法</h4>
<p>可以直接判断属性是否存在于当前实例中，TypeScript 会直接推断出对应的接口。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">trainAnimalSecond</span>(<span class="hljs-params">animal: Bird | Dog</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;sing&quot;</span> <span class="hljs-keyword">in</span> animal) {
    animal.<span class="hljs-title hljs-function">sing</span>();
  }
}
</code></pre>
<h4 id="typeof语法"><code>typeof</code>语法</h4>
<p>和使用<code>in</code>语法类型，<code>typeof</code>语法也能让 TypeScript 做出正确的类型推断。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">addSomething</span>(<span class="hljs-params">firstNum: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, secondNum: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> firstNum === <span class="hljs-string">&quot;string&quot;</span> || <span class="hljs-keyword">typeof</span> secondNum === <span class="hljs-string">&quot;string&quot;</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${firstNum}</span><span class="hljs-subst">${secondNum}</span>`</span>;
  }
  <span class="hljs-keyword">return</span> firstNum + secondNum;
}
</code></pre>
<h2 id="枚举类型">枚举类型</h2>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-built_in">enum</span> <span class="hljs-title hljs-class">Status</span> {
  <span class="hljs-variable hljs-constant">ONLINE</span>,
  <span class="hljs-variable hljs-constant">OFFLINE</span>,
  <span class="hljs-variable hljs-constant">DELETED</span>,
}

<span class="hljs-keyword">function</span> <span class="hljs-title hljs-function">getDetail</span>(<span class="hljs-params">status: Status</span>) {
  <span class="hljs-keyword">switch</span> (status) {
    <span class="hljs-keyword">case</span> <span class="hljs-title hljs-class">Status</span>.<span class="hljs-property">ONLINE</span>:
      <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(<span class="hljs-string">&quot;online!&quot;</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title hljs-class">Status</span>.<span class="hljs-property">OFFLINE</span>:
      <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(<span class="hljs-string">&quot;offline!&quot;</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title hljs-class">Status</span>.<span class="hljs-property">DELETED</span>:
      <span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(<span class="hljs-string">&quot;deleted!&quot;</span>);
      <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-title hljs-function">getDetail</span>(<span class="hljs-number">0</span>);
</code></pre>
<h2 id="函数泛型">函数泛型</h2>
<p>泛指的类型（generic）。通俗的说，就是不专门注解函数的参数为指定的某一个类型，函数可以接受多个类型，但参数的类型必须统一。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> join&lt;T&gt;(<span class="hljs-attr">first</span>: T, <span class="hljs-attr">second</span>: T): <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${first}</span><span class="hljs-subst">${second}</span>`</span>;
}

join&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);
</code></pre>
<p>也可以为指定数组内的属性指定泛型</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-comment">// function map&lt;T&gt;(params: Array&lt;T&gt;) {</span>
<span class="hljs-comment">//   return params;</span>
<span class="hljs-comment">// }</span>
<span class="hljs-keyword">function</span> map&lt;T&gt;(<span class="hljs-attr">params</span>: T[]) {
  <span class="hljs-keyword">return</span> params;
}
map&lt;<span class="hljs-built_in">number</span>&gt;([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
</code></pre>
<p>泛型还支持多个类型</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">function</span> join&lt;T, Y&gt;(<span class="hljs-attr">first</span>: T, <span class="hljs-attr">second</span>: Y): <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${first}</span><span class="hljs-subst">${second}</span>`</span>;
}

join&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">2</span>);
</code></pre>
<p>函数的返回类型也可以使用泛型。</p>
<h3 id="类中的泛型">类中的泛型</h3>
<p>类也是同样的可以定义泛型</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">DataManager</span>&lt;T&gt; {
  <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> data: T[]</span>) {}
  <span class="hljs-title hljs-function">getItem</span>(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">data</span>[index];
  }
}
<span class="hljs-keyword">const</span> myData = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">DataManager</span>&lt;<span class="hljs-built_in">number</span>&gt;([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(myData.<span class="hljs-title hljs-function">getItem</span>(<span class="hljs-number">2</span>));
</code></pre>
<h3 id="泛型的继承">泛型的继承</h3>
<p>泛型可以继承自接口</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title hljs-class">Item</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">DataManager</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title hljs-class">Item</span>&gt; {
  <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> data: T[]</span>) {}
  <span class="hljs-title hljs-function">getItem</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable hljs-language">this</span>.<span class="hljs-property">data</span>[index].<span class="hljs-property">name</span>;
  }
}
<span class="hljs-keyword">const</span> myData = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">DataManager</span>([
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xfy&quot;</span>,
  },
]);
<span class="hljs-variable hljs-language">console</span>.<span class="hljs-title hljs-function">log</span>(myData.<span class="hljs-title hljs-function">getItem</span>(<span class="hljs-number">0</span>));
</code></pre>
<h3 id="作为类型注解">作为类型注解</h3>
<p>泛型也可以作为一个具体的类型注解</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">const</span> xfy = &lt;T&gt;(<span class="hljs-attr">params</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> params;
};
</code></pre>
<h2 id="namespace">namespace</h2>
<p>命名空间，可以直接为指定的代码生成作用域。并导出需要的代码。</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-keyword">namespace</span> <span class="hljs-title hljs-class">Home</span> {
  <span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Header</span> {
    <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> header = <span class="hljs-variable hljs-language">document</span>.<span class="hljs-title hljs-function">createElement</span>(<span class="hljs-string">&quot;header&quot;</span>);
      header.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Here is head.`</span>;
      <span class="hljs-variable hljs-language">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title hljs-function">append</span>(header);
    }
  }
  <span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Content</span> {
    <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> div = <span class="hljs-variable hljs-language">document</span>.<span class="hljs-title hljs-function">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
      div.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Here is content.`</span>;
      <span class="hljs-variable hljs-language">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title hljs-function">append</span>(div);
    }
  }
  <span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Footer</span> {
    <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> footer = <span class="hljs-variable hljs-language">document</span>.<span class="hljs-title hljs-function">createElement</span>(<span class="hljs-string">&quot;footer&quot;</span>);
      footer.<span class="hljs-property">textContent</span> = <span class="hljs-string">`© 2021 xfy`</span>;
      <span class="hljs-variable hljs-language">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title hljs-function">append</span>(footer);
    }
  }
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">Page</span> {
    <span class="hljs-title hljs-function">constructor</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Header</span>();
      <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Content</span>();
      <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">Footer</span>();
    }
  }
}
</code></pre>
<p>命名空间也可以在多个文件之间相互导入导出，就和模块系统类似。但使用了命名空间之间的互相导入之后，需要在<code>tsconfig.json</code>中修改模块系统为<code>amd</code>或<code>system</code>。</p>
<p>使用依赖注释：</p>
<pre><button type="button" class="chakra-button css-19bp9bt">COPY</button><code class="hljs language-ts"><span class="hljs-comment">///&lt;reference path=&#x27;./test.ts&#x27; /&gt;</span>
</code></pre></section></article></div><style data-emotion="css 1i6v8fa">.css-1i6v8fa{min-height:346px;}@media screen and (min-width: 30em){.css-1i6v8fa{min-height:350px;}}</style><div class="css-1i6v8fa"></div><style data-emotion="css 3ydw18">.css-3ydw18{height:3px;width:50px;background:var(--chakra-colors-gray-500);border-radius:var(--chakra-radii-xl);margin-top:2.5rem;}</style><div class="css-3ydw18"></div><style data-emotion="css 1lwvw50">.css-1lwvw50{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-flow:column;-webkit-flex-flow:column;-ms-flex-flow:column;flex-flow:column;padding-top:1.5rem;padding-bottom:1.5rem;}</style><footer class="css-1lwvw50"><style data-emotion="css yld109">.css-yld109{color:var(--chakra-colors-gray-600);font-weight:var(--chakra-fontWeights-bold);margin-bottom:0.5rem;}</style><p class="chakra-text css-yld109">©<!-- -->2022<!-- --> 小肥羊</p><style data-emotion="css 3eyczr">.css-3eyczr{color:var(--chakra-colors-gray-400);font-size:small;}</style><p class="chakra-text css-3eyczr">Powered by Next.js ❤️ Chakra UI</p></footer></div><style data-emotion="css kl7qz4">.css-kl7qz4{display:none;position:-webkit-sticky;position:sticky;top:3rem;margin-top:3rem;}@media screen and (min-width: 30em){.css-kl7qz4{display:none;}}@media screen and (min-width: 48em){.css-kl7qz4{display:none;}}@media screen and (min-width: 62em){.css-kl7qz4{display:block;}}</style><div class="css-kl7qz4"><h2 id="table-of-contents">Table of contents</h2>
<ul>
<li>
<p><style data-emotion="css wox0k7">.css-wox0k7{transition-property:var(--chakra-transition-property-common);transition-duration:var(--chakra-transition-duration-fast);transition-timing-function:var(--chakra-transition-easing-ease-out);cursor:pointer;-webkit-text-decoration:none;text-decoration:none;outline:2px solid transparent;outline-offset:2px;color:inherit;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.css-wox0k7:hover,.css-wox0k7[data-hover]{-webkit-text-decoration:underline;text-decoration:underline;}.css-wox0k7:focus,.css-wox0k7[data-focus]{box-shadow:var(--chakra-shadows-outline);}</style><a class="chakra-link css-wox0k7" href="#%E7%B1%BB%E5%9E%8B">类型</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E5%BC%95%E7%94%A8%E5%80%BC">引用值</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B">函数返回类型</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#never">never</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3">解构参数类型注解</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3">匿名函数的类型注解</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%83%E7%BB%84">数组和元组</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3">数组的类型注解</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">类型别名</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E5%85%83%E7%BB%84">元组</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#interface">interface</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8Cinterface%E5%8C%BA%E5%88%AB">类型别名和<code>interface</code>区别</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B">可选类型</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E5%8F%AA%E8%AF%BB">只读</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">强类型检查</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7%E6%B3%A8%E8%A7%A3">其他属性注解</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E6%B3%A8%E8%A7%A3%E6%96%B9%E6%B3%95">注解方法</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E7%B1%BB">类</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF">接口继承</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E7%B1%BB-1">类</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#public">public</a></li>
<li><a class="chakra-link css-wox0k7" href="#private">private</a></li>
<li><a class="chakra-link css-wox0k7" href="#protected">protected</a></li>
<li><a class="chakra-link css-wox0k7" href="#constructor">constructor</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></p>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#dts">.d.ts</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80">定义全局</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">函数重载</a></p>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#tsconfig">tsconfig</a></p>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4">联合类型与类型保护</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4">类型保护</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a></p>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#%E5%87%BD%E6%95%B0%E6%B3%9B%E5%9E%8B">函数泛型</a></p>
<ul>
<li><a class="chakra-link css-wox0k7" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">类中的泛型</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF">泛型的继承</a></li>
<li><a class="chakra-link css-wox0k7" href="#%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3">作为类型注解</a></li>
</ul>
</li>
<li>
<p><a class="chakra-link css-wox0k7" href="#namespace">namespace</a></p>
</li>
</ul></div></div><span></span></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"typescript-pieces","content":"\n## 类型\n\n```ts\n// 基础类型 null, undefined, symbol, boolean, void\nconst count: number = 123;\nconst teacherName: string = 'Dell';\n\n// 对象类型\n\nclass Person {}\n\nconst teacher: {\n  name: string;\n  age: number;\n} = {\n  name: 'Dell',\n  age: 18\n};\n\nconst numbers: number[] = [1, 2, 3];\n\nconst dell: Person = new Person();\n\nconst getTotal: () =\u003e number = () =\u003e {\n  return 123;\n};\n\n```\n\n### 基本类型\n\n当复制和变量定义不在同一行时，ts 就无法推断类型。\n\n```js\nstring, number\n```\n\n```js\nnull, undefined, symbol, boolean, void\n```\n\n### 引用值\n\n数组，对象，类，函数\n\n## 函数返回类型\n\n函数也可以指定返回值的静态类型\n\n```ts\nfunction test(data: { x: number }): object {\n  console.log(data.x);\n  return data;\n}\n\ntest({ x: 123 });\n\n```\n\n如果没有返回值，则使用`void`指定\n\n```ts\nfunction test(data: { x: number }): void {\n  console.log(data.x);\n}\n\ntest({ x: 123 });\n\n```\n\n### never\n\n指定`never`返回值表示该函数永远不会执行完\n\n```ts\nfunction test(): never {\n  while (true) {}\n}\n\n```\n\n### 解构参数类型注解\n\n```ts\nfunction add({\n  firstNumber,\n  secondNumber,\n}: {\n  firstNumber: number;\n  secondNumber: number;\n}): number {\n  return firstNumber + secondNumber;\n}\nadd({ firstNumber: 1, secondNumber: 2 });\n\n```\n\n### 匿名函数的类型注解\n\n```ts\nconst fn = (data: { x: number }): number =\u003e {\n  return data.x;\n};\nconst fnc: (str: string) =\u003e string = (str) =\u003e {\n  return str;\n};\n\n```\n\n## 数组和元组\n\n### 数组的类型注解\n\n```ts\nconst arr: (number | string)[] = [1, '2', 3];\nconst arr: (number | string)[] = [1, '2', 3];\nconst objArr: object[] = [{}, {}];\nconst obj1Arr: { name: string }[] = [{ name: 'xfy' }];\nconst obj2Arr: ({ name: string } | number)[] = [{ name: 'xfy' }, 123];\n\n```\n\n### 类型别名\n\n类型别名和`interface`类似\n\n```ts\ntype User = {\n  name: string;\n  age: number;\n};\nconst arr1: User[] = [{ name: 'xfy', age: 18 }];\n\ninterface User1 {\n  name: string;\n  age: number;\n}\nconst arr2: User1[] = [{ name: 'xfy', age: 18 }];\n\n```\n\n### 元组\n\ntuple，数据解构和数组类似，但可以指定每一项的数据类型。\n\n```ts\nconst tuple: [string, number] = ['xfy', 18];\nconst csv1: [string, number][] = [];\n```\n\n## interface\n\ninterface 用于定义一个新的类型集合\n\n```ts\ninterface Person3 {\n  name: string;\n}\nconst sayName = (person: Person3): void =\u003e {\n  console.log(person.name);\n};\nsayName({ name: 'xfy' });\n\n```\n\n### 类型别名和`interface`区别\n\n类型别名可以直接指定单个类型，而接口必须为一个对象\n\n```ts\ninterface Person1 {\n  name: string;\n}\ntype Person2 = string;\n\n```\n\n能用接口的尽量使用接口来定义。\n\n### 可选类型\n\n一种类似于可选链的语法，通过 interface 注解可选的数据类型\n\n```ts\ninterface Person4 {\n  name: string;\n  age?: number;\n}\nconst fn1 = (person: Person4): void =\u003e {\n  console.log(person.name);\n};\nfn1({ name: 'xfy', age: 18 });\n```\n\n### 只读\n\n```ts\ninterface Person5 {\n  readonly name: string;\n  age?: number;\n}\nconst fn2 = (person: Person5): void =\u003e {\n  console.log(person.name);\n  person.name = 'test';  // Cannot assign to 'name' because it is a read-only property.\n};\nfn2({ name: 'xfy', age: 18 });\n\n```\n\n### 强类型检查\n\n当 interface 注解类型时，通过直接传递对象字面量就会进行强类型检查。ts 会检查对象字面量内的每个属性，多余的属性将无法通过检查。\n\n而通过使用一个对象表达式将一个变量进行传递时，检查不会那么严格。\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n}\nconst fn3 = (person: Person6): void =\u003e {\n  console.log(person.name);\n  // person.name = 'test';\n};\nfn3({ name: 'xfy', sex: 'female' });  //  'sex' does not exist in type 'Person6'.\nconst person1 = {\n  name: 'xfy',\n  sex: 'female',\n};\nfn3(person1);\n```\n\n### 其他属性注解\n\n通过 interface 直接注解的类型无法传递对象字面量传递未注解的属性，可以使用定义其他变量的类型注解\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n}\nconst fn3 = (person: Person6): void =\u003e {\n  console.log(person.name);\n  // person.name = 'test';\n};\nfn3({ name: 'xfy', sex: 'female' });\n```\n\n### 注解方法\n\n除了注解指定的属性类型，还可以注解方法，并注解函数的返回值类型\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n  say(): string;\n}\nconst fn3 = (person: Person6): void =\u003e {\n  console.log(person.name);\n  // person.name = 'test';\n};\nfn3({\n  name: 'xfy',\n  sex: 'female',\n  say() {\n    return 'yyy';\n  },\n});\n```\n\n### 类\n\n使用 implements 语法\n\n```ts\ninterface Person6 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n  say(): string;\n}\nclass User2 implements Person6 {\n  name: 'test';\n  say() {\n    return 'yyy';\n  }\n}\n\n```\n\n### 接口继承\n\n接口继承的语法与类继承类似\n\n```ts\ninterface Person7 {\n  readonly name: string;\n  age?: number;\n  [propName: string]: any;\n  say(): string;\n}\ninterface Teach extends Person7 {\n  teach(): void;\n}\nconst test3 = (person: Teach): void =\u003e {};\ntest3({\n  name: 'xfy',\n  say() {\n    return 'yyy';\n  },\n  teach() {},\n});\n\n```\n\n## 类\n\nTypeScript 中为类定义了多个声明关键字。帮助类声明公共与私有属性。\n\n### public\n\n默认情况下直接声明的属性是通过 public 声明的，即在外部也能正常访问该属性。\n\n```ts\nclass Person {\n  name = 'xfy';\n  sayName() {\n    return this.name;\n  }\n}\n\nlet xfy = new Person();\nconsole.log(xfy.sayName());\nconsole.log(xfy.name);\n```\n\n### private\n\nprivate 与 public 相对立。通过 private 声明的属性只能在当前类的内部被访问到，即使是继承的子类也无法直接访问。\n\n```ts\nclass Person {\n  private name = 'xfy';\n  sayName() {\n    return this.name;\n  }\n}\n\nlet xfy = new Person();\nconsole.log(xfy.sayName());\nconsole.log(xfy.name); // Property 'name' is private and only accessible within class 'Person'.\n\nclass Teacher extends Person {\n  say() {\n    return this.name;  // Property 'name' is private and only accessible within class 'Person'.\n  }\n}\n\n```\n\n### protected\n\n与 private 类型，protected 的属性也无法在外部被访问。但是可以在继承的子类中被访问到。\n\n```ts\nclass Person {\n  private name = 'xfy';\n  sayName() {\n    return this.name;\n  }\n}\n\nlet xfy = new Person();\nconsole.log(xfy.sayName());\nconsole.log(xfy.name); // Property 'name' is private and only accessible within class 'Person'.\n\nclass Teacher extends Person {\n  say() {\n    return this.name;  // ok\n  }\n}\n\n```\n\n### constructor\n\n与 JavaScript 的 constructor 不同的是，在 TypeScript 中 constrcutor 需要先在类中定义对应的 public 属性。\n\n```ts\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nlet xfy = new Person('xfy');\nconsole.log(xfy.name);\n```\n\n为了方便起见，TypeScript 也有简写 constructor 参数的方法。并且不需要再在内部添加`this.name`了。编译器会帮我们自动生成。\n\n```ts\nclass Person {\n  // name: string;\n  constructor(public name: string) {\n    // this.name = name;\n  }\n}\nlet xfy = new Person('xfy');\nconsole.log(xfy.name);\n\n```\n\nconstructor 继承时的用法与传统 JavaScript 类似。\n\n```ts\nclass Person {\n  // name: string;\n  constructor(public name: string) {\n    // this.name = name;\n  }\n}\nlet xfy = new Person('xfy');\nconsole.log(xfy.name);\n\nclass Teacher extends Person {\n  constructor(name: string, public age: number) {\n    super(name);\n  }\n}\nlet t = new Teacher('xfy', 18);\n\n```\n\n\u003e 即使父类没有 constructor，子类继承时也需要调用`super()`\n\n### 抽象类\n\n在定义多个有相似方法的类时，可以定义一个抽象类来为同样的方法注解类型。抽象类中也可以包含实际的内容。\n\n```ts\nabstract class Geo {\n  width: number;\n  abstract getAare(): number;\n}\n\nclass Circle extends Geo {\n  // width = '123';\n  width = 123;\n  getAare() {\n    return 123;\n  }\n}\nclass Square extends Geo {\n  getAare() {\n    return 123;\n  }\n}\nclass Triangle extends Geo {\n  getAare() {\n    return 123;\n  }\n}\n\n```\n\n## 单例模式\n\n单例模式（Singleton Pattern）是多数编程软件中常用的设计模式。通过 TypeScript 就可以为 JavaScript 创建一个单例模式的类。\n\n这里通过 private 将 constructor 隐藏在类的内部。在类体上暴露一个方法`getInstance()`，通过这个方法来获取唯一的实例。同时在类体上还定义一个 private 属性 instance，它的类型注解就是该类。每次调用`getInstance()`方法时，通过检查 instance 是否有值，没有就创建一个新的实例，并缓存在 instance 内。后续直接返回 instance。这样就能够保证后续创建的实例都是同一个实例。\n\n```ts\nclass Demo {\n  private static instance: Demo;\n  private constructor(public name: string) {}\n  static getInstance(name: string) {\n    if (!Demo.instance) {\n      Demo.instance = new Demo(name);\n    }\n    return Demo.instance;\n  }\n}\nlet t1 = Demo.getInstance('xfy');\nlet t2 = Demo.getInstance('dfy');\nconsole.log(t1.name);\nconsole.log(t2.name);\nconsole.log(t1 === t2);\n\n```\n\n## .d.ts\n\n传统的 js 在被引入到 ts 中无法正确的被推断出类型。需要使用`.d.ts`已经注解好类型的文件来转译。\n\n通常在 @types 里`https://www.npmjs.com/package/@types`\n\n### 定义全局\n\n```ts\n$(function () {\n    $('body').html('\u003ch1\u003eHi, there\u003c/h1\u003e')\n})\n```\n\n```ts\n// 全局变量\ndeclare var $: (param: () =\u003e void)  =\u003e void;\n```\n\n```ts\ninterface JqueryInstance {\n    html: (content: string) =\u003e {}\n}\n// 函数重载\ndeclare function $(param: () =\u003e void): void;\ndeclare function $(patam: string): JqueryInstance;\n```\n\n## 函数重载\n\n使用 interface 的语法，实现函数重载\n\n```ts\ninterface JQuery {\n    (param: () =\u003e void): void;\n    (patam: string): JqueryInstance;\n}\ndeclare var $: JQuery;\n```\n\n## tsconfig\n\n使用`tsc --init`初始化一个项目时，会自动生成一个带有注释的`tsconfig.json`配置文件。这个文件就是对 TypeScript 编译的一些配置文件。\n\n一个默认的配置文件可能是这样的：\n\n```json\n{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig.json to read more about this file */\n\n    /* Basic Options */\n    // \"incremental\": true,                         /* Enable incremental compilation */\n    \"target\": \"ESNEXT\",                                /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */\n    \"module\": \"commonjs\",                           /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */\n    // \"lib\": [],                                   /* Specify library files to be included in the compilation. */\n    // \"allowJs\": true,                             /* Allow javascript files to be compiled. */\n    // \"checkJs\": true,                             /* Report errors in .js files. */\n    // \"jsx\": \"preserve\",                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */\n    // \"declaration\": true,                         /* Generates corresponding '.d.ts' file. */\n    // \"declarationMap\": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */\n    // \"sourceMap\": true,                           /* Generates corresponding '.map' file. */\n    // \"outFile\": \"./\",                             /* Concatenate and emit output to single file. */\n    // \"outDir\": \"./\",                              /* Redirect output structure to the directory. */\n    // \"rootDir\": \"./\",                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */\n    // \"composite\": true,                           /* Enable project compilation */\n    // \"tsBuildInfoFile\": \"./\",                     /* Specify file to store incremental compilation information */\n    // \"removeComments\": true,                      /* Do not emit comments to output. */\n    // \"noEmit\": true,                              /* Do not emit outputs. */\n    // \"importHelpers\": true,                       /* Import emit helpers from 'tslib'. */\n    // \"downlevelIteration\": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */\n    // \"isolatedModules\": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */\n\n    /* Strict Type-Checking Options */\n    \"strict\": true,                                 /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                    /* Enable strict null checks. */\n    // \"strictFunctionTypes\": true,                 /* Enable strict checking of function types. */\n    // \"strictBindCallApply\": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */\n    // \"strictPropertyInitialization\": true,        /* Enable strict checking of property initialization in classes. */\n    // \"noImplicitThis\": true,                      /* Raise error on 'this' expressions with an implied 'any' type. */\n    // \"alwaysStrict\": true,                        /* Parse in strict mode and emit \"use strict\" for each source file. */\n\n    /* Additional Checks */\n    // \"noUnusedLocals\": true,                      /* Report errors on unused locals. */\n    // \"noUnusedParameters\": true,                  /* Report errors on unused parameters. */\n    // \"noImplicitReturns\": true,                   /* Report error when not all code paths in function return a value. */\n    // \"noFallthroughCasesInSwitch\": true,          /* Report errors for fallthrough cases in switch statement. */\n    // \"noUncheckedIndexedAccess\": true,            /* Include 'undefined' in index signature results */\n    // \"noPropertyAccessFromIndexSignature\": true,  /* Require undeclared properties from index signatures to use element accesses. */\n\n    /* Module Resolution Options */\n    // \"moduleResolution\": \"node\",                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\n    // \"baseUrl\": \"./\",                             /* Base directory to resolve non-absolute module names. */\n    // \"paths\": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */\n    // \"rootDirs\": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeRoots\": [],                             /* List of folders to include type definitions from. */\n    // \"types\": [],                                 /* Type declaration files to be included in compilation. */\n    // \"allowSyntheticDefaultImports\": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\n    \"esModuleInterop\": true,                        /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */\n    // \"preserveSymlinks\": true,                    /* Do not resolve the real path of symlinks. */\n    // \"allowUmdGlobalAccess\": true,                /* Allow accessing UMD globals from modules. */\n\n    /* Source Map Options */\n    // \"sourceRoot\": \"\",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */\n    // \"mapRoot\": \"\",                               /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                     /* Emit a single file with source maps instead of having a separate file. */\n    // \"inlineSources\": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */\n\n    /* Experimental Options */\n    // \"experimentalDecorators\": true,              /* Enables experimental support for ES7 decorators. */\n    // \"emitDecoratorMetadata\": true,               /* Enables experimental support for emitting type metadata for decorators. */\n\n    /* Advanced Options */\n    \"skipLibCheck\": true,                           /* Skip type checking of declaration files. */\n    \"forceConsistentCasingInFileNames\": true        /* Disallow inconsistently-cased references to the same file. */\n  }\n}\n\n```\n\n仔细看的话，配置文件内主要包含一个大的字段`\"compilerOptions\"`，这是针对编译时的配置。对文件的配置还有`include`和`exclude`：\n\n```json\n{\n  \"exclude\": [\"./src/config.ts\"],\n  \"compilerOptions\": {\n\t// ...\n  }\n}\n\n```\n\n## 联合类型与类型保护\n\n当定义了多个 interface 需要同时使用时，可以使用`|`运算符来同时使用。但是这样也会遇到一个小问题，同时使用两个 interface 时，语法提示只会提示二者共有的类型注解。\n\n因为不能保证传入的参数一定会拥有独有的属性\n\n```ts\ninterface Bird {\n  fly: boolean;\n  sing: () =\u003e {};\n}\ninterface Dog {\n  fly: boolean;\n  bark: () =\u003e {};\n}\n\nfunction trainAnimal(animal: Bird | Dog) {\n  console.log(animal);\n}\n```\n\n![image-20210329172943170](../images/TypeScript%E4%B8%B4%E7%A2%8E%E7%AC%94%E8%AE%B0/image-20210329172943170.png)\n\n### 类型保护\n\n类型保护有多个方法，作用就是在特定情况下访问独有的属性。\n\n#### 类型断言\n\n断言的目的就是在当前情况下，我非常清楚指定传进来的参数有指定的参数。\n\n假设在当前例子里，参数中的`fly`属性只要为`true`时，就一定能确定是`Bird`接口的类型。那么就可以断言为：\n\n```ts\ninterface Bird {\n  fly: boolean;\n  sing: () =\u003e {};\n}\ninterface Dog {\n  fly: boolean;\n  bark: () =\u003e {};\n}\n\nfunction trainAnimal(animal: Bird | Dog) {\n  if (animal.fly) {\n    (animal as Bird).sing();\n  }\n}\n```\n\n#### `in`语法\n\n可以直接判断属性是否存在于当前实例中，TypeScript 会直接推断出对应的接口。\n\n```ts\nfunction trainAnimalSecond(animal: Bird | Dog) {\n  if (\"sing\" in animal) {\n    animal.sing();\n  }\n}\n```\n\n#### `typeof`语法\n\n和使用`in`语法类型，`typeof`语法也能让 TypeScript 做出正确的类型推断。\n\n```ts\nfunction addSomething(firstNum: string | number, secondNum: string | number) {\n  if (typeof firstNum === \"string\" || typeof secondNum === \"string\") {\n    return `${firstNum}${secondNum}`;\n  }\n  return firstNum + secondNum;\n}\n```\n\n## 枚举类型\n\n```ts\nenum Status {\n  ONLINE,\n  OFFLINE,\n  DELETED,\n}\n\nfunction getDetail(status: Status) {\n  switch (status) {\n    case Status.ONLINE:\n      console.log(\"online!\");\n      break;\n    case Status.OFFLINE:\n      console.log(\"offline!\");\n      break;\n    case Status.DELETED:\n      console.log(\"deleted!\");\n      break;\n  }\n}\n\ngetDetail(0);\n```\n\n## 函数泛型\n\n泛指的类型（generic）。通俗的说，就是不专门注解函数的参数为指定的某一个类型，函数可以接受多个类型，但参数的类型必须统一。\n\n```ts\nfunction join\u003cT\u003e(first: T, second: T): string {\n  return `${first}${second}`;\n}\n\njoin\u003cstring\u003e(\"1\", \"2\");\n```\n\n也可以为指定数组内的属性指定泛型\n\n```ts\n// function map\u003cT\u003e(params: Array\u003cT\u003e) {\n//   return params;\n// }\nfunction map\u003cT\u003e(params: T[]) {\n  return params;\n}\nmap\u003cnumber\u003e([1, 2, 3]);\n```\n\n泛型还支持多个类型\n\n```ts\nfunction join\u003cT, Y\u003e(first: T, second: Y): string {\n  return `${first}${second}`;\n}\n\njoin\u003cstring, number\u003e(\"1\", 2);\n```\n\n函数的返回类型也可以使用泛型。\n\n### 类中的泛型\n\n类也是同样的可以定义泛型\n\n```ts\nclass DataManager\u003cT\u003e {\n  constructor(private data: T[]) {}\n  getItem(index: number) {\n    return this.data[index];\n  }\n}\nconst myData = new DataManager\u003cnumber\u003e([1, 2, 3]);\nconsole.log(myData.getItem(2));\n```\n\n### 泛型的继承\n\n泛型可以继承自接口\n\n```ts\ninterface Item {\n  name: string;\n}\n\nclass DataManager\u003cT extends Item\u003e {\n  constructor(private data: T[]) {}\n  getItem(index: number): string {\n    return this.data[index].name;\n  }\n}\nconst myData = new DataManager([\n  {\n    name: \"xfy\",\n  },\n]);\nconsole.log(myData.getItem(0));\n```\n\n### 作为类型注解\n\n泛型也可以作为一个具体的类型注解\n\n```ts\nconst xfy = \u003cT\u003e(params: T): T =\u003e {\n  return params;\n};\n```\n\n## namespace\n\n命名空间，可以直接为指定的代码生成作用域。并导出需要的代码。\n\n```ts\nnamespace Home {\n  class Header {\n    constructor() {\n      const header = document.createElement(\"header\");\n      header.textContent = `Here is head.`;\n      document.body.append(header);\n    }\n  }\n  class Content {\n    constructor() {\n      const div = document.createElement(\"div\");\n      div.textContent = `Here is content.`;\n      document.body.append(div);\n    }\n  }\n  class Footer {\n    constructor() {\n      const footer = document.createElement(\"footer\");\n      footer.textContent = `© 2021 xfy`;\n      document.body.append(footer);\n    }\n  }\n  export class Page {\n    constructor() {\n      new Header();\n      new Content();\n      new Footer();\n    }\n  }\n}\n```\n\n命名空间也可以在多个文件之间相互导入导出，就和模块系统类似。但使用了命名空间之间的互相导入之后，需要在`tsconfig.json`中修改模块系统为`amd`或`system`。\n\n使用依赖注释：\n\n```ts\n///\u003creference path='./test.ts' /\u003e\n```\n\n","desc":"类型\n\n\n\n基本类型\n\n当复制和变量定义不在同一行时，ts 就无法推断类型。\n\n\n\n引用值\n\n数组，对象，类，函数\n\n函数返回类型\n\n函数也可以指定返回值的静态类型\n\n\n\n如果没有返回值，则使用voi...","title":"TypeScript临碎笔记","date":"2021-06-02T12:13:06.000Z","tags":"TypeScript","categories":"笔记","url":"typescript-pieces","index_img":"/images/TypeScript%E4%B8%B4%E7%A2%8E%E7%AC%94%E8%AE%B0/logo.svg"}},"__N_SSG":true},"page":"/p/[slug]","query":{"slug":"typescript-pieces"},"buildId":"k6NIc4JfXUsE09z9QnALx","isFallback":false,"dynamicIds":[3419,6929,9125,3780,2980,5106,1189],"gsp":true,"scriptLoader":[]}</script></body></html>